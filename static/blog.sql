-- MySQL dump 10.13  Distrib 5.7.20, for Linux (x86_64)
--
-- Host: localhost    Database: blog
-- ------------------------------------------------------
-- Server version	5.7.20-0ubuntu0.16.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Current Database: `blog`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `blog` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `blog`;

--
-- Table structure for table `Article`
--

DROP TABLE IF EXISTS `Article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `Article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(100) NOT NULL,
  `body` longtext NOT NULL,
  `created_time` datetime(6) NOT NULL,
  `last_modified_time` datetime(6) NOT NULL,
  `status` varchar(1) NOT NULL,
  `abstract` varchar(60) DEFAULT NULL,
  `views` int(10) unsigned NOT NULL,
  `likes` int(10) unsigned NOT NULL,
  `imgurl` varchar(255) DEFAULT NULL,
  `topped` tinyint(1) NOT NULL,
  `author_id` int(11) NOT NULL,
  `category_id` int(11),
  `property` varchar(1) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `Article_author_id_3fd8bb5d27fca8d0_fk_auth_user_id` (`author_id`),
  KEY `Article_b583a629` (`category_id`),
  CONSTRAINT `Article_author_id_3fd8bb5d27fca8d0_fk_auth_user_id` FOREIGN KEY (`author_id`) REFERENCES `auth_user` (`id`),
  CONSTRAINT `Article_category_id_24d2f48a6b613793_fk_Category_id` FOREIGN KEY (`category_id`) REFERENCES `Category` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Article`
--

LOCK TABLES `Article` WRITE;
/*!40000 ALTER TABLE `Article` DISABLE KEYS */;
INSERT INTO `Article` VALUES (1,'Python datetime timestamp','做开发中难免时间类型之间的转换， 最近就发现前端js和后端django经常要用到这个转换， 其中jsDate.now()精确到毫秒，而Python中Datetime.datetime.now()是精确到微秒的。\r\n\r\nConvert datetime to timestamp\r\nfrom datetime import datetime\r\nimport time\r\ndt = datetime(2017,12,27,15,49)\r\nts = time.mktime(dt.timetuple())\r\nprint ts\r\n\r\n字符串日期时间转换成时间戳\r\n[python] view plain copy\r\n\r\n# \'2015-08-28 16:43:37.283\' --> 1440751417.283  \r\n# 或者 \'2015-08-28 16:43:37\' --> 1440751417.0  \r\ndef string2timestamp(strValue):  \r\n  \r\n    try:          \r\n        d = datetime.datetime.strptime(strValue, \"%Y-%m-%d %H:%M:%S.%f\")  \r\n        t = d.timetuple()  \r\n        timeStamp = int(time.mktime(t))  \r\n        timeStamp = float(str(timeStamp) + str(\"%06d\" % d.microsecond))/1000000  \r\n        print timeStamp  \r\n        return timeStamp  \r\n    except ValueError as e:  \r\n        print e  \r\n        d = datetime.datetime.strptime(str2, \"%Y-%m-%d %H:%M:%S\")  \r\n        t = d.timetuple()  \r\n        timeStamp = int(time.mktime(t))  \r\n        timeStamp = float(str(timeStamp) + str(\"%06d\" % d.microsecond))/1000000  \r\n        print timeStamp  \r\n        return timeStamp  \r\n   \r\n时间戳转换成字符串日期时间\r\n[python] view plain copy\r\n\r\n# 1440751417.283 --> \'2015-08-28 16:43:37.283\'  \r\ndef timestamp2string(timeStamp):  \r\n    try:  \r\n        d = datetime.datetime.fromtimestamp(timeStamp)  \r\n        str1 = d.strftime(\"%Y-%m-%d %H:%M:%S.%f\")  \r\n        # 2015-08-28 16:43:37.283000\'  \r\n        return str1  \r\n    except Exception as e:  \r\n        print e  \r\n        return \'\'','2018-01-27 09:33:39.820774','2018-03-12 17:45:19.115315','p','',61,0,'/upload/MYXJ_20180120221144_fast.jpg',0,1,5,'r'),(2,'根据html页面id寻找对应的Js文件','想学习别人的JS方法，这个时候打开别人的html,找到对应id，然后按F12进入开发者模式，ctrl+shift+f打开全局搜索，输入id,就可以找到对应文件！mark一下,还是那句话，不管是爬动态加载的内容（查找到Web API）还是任何有关Web的，90%的工作F12都可以完成，还有10%是聪明！\r\n\r\n人生当自勉，学习需坚持。从这一刻开始，我依旧是我，只是心境再不同。不论今后的路如何，我都会在心底默默鼓励自己，坚持不懈，等待那一场破茧的美丽。','2018-01-27 09:40:48.902240','2018-03-20 11:52:25.971320','p','',27,0,'/upload/MYXJ_20171106152329_fast.jpg',0,1,6,'o'),(3,'Django+Markdown+Pygments 支持Markdown 实现代码高亮','Markdown部分\r\n\r\n1.安装markdown pip install markdown\r\n\r\n2.在view.py中导入包 from markdown import markdown\r\n\r\n3.使用markdown()将需要用markdown格式解析的内容（字符串）封装起来。 注：models里面有一个Article类，Article里面有一项是content存储博客内容。\r\n\r\n```\r\ndef detail(request, id):\r\n    try:\r\n        post = Article.objects.get(id=str(id))\r\n        #for markdown test\r\n        post.content = markdown(post.content) \r\n    except Article.DoesNotExist:\r\n        raise Http404\r\n    return render(request, \'post.html\', {\'post\' : post})\r\n```\r\n在后台编辑博文 \r\n\r\n4.> ## This is a test. \r\n\r\n5.> \r\n\r\n6.> 1. This is the first list item. \r\n\r\n7.> 2. This is the second list item.\r\n\r\n\r\n前台显示 {{ post.content | safe}}，注意使用了safe过滤器，防止内容在输出前被解析。 \r\nps：和这个问题是一个原因，django数据库里Html代码，如何在前台让浏览器正确解析?\r\n\r\n完\r\n\r\n##Pygments部分\r\n\r\n1.官网下载最新的版本的Pygments。\r\n\r\n2.使用pip安装下载的包Pygments-2.0.2.tar.gz,敲命令pip install Pygments-2.0.2.tar。\r\n\r\n3.运行如下命令pygmentize -S default -f html -a .codehilite > code.css，在文件夹下会发现生成了\r\n\r\n4.code.css文件，将这个css文件加入到你的static文件夹下style里面（随便你放哪里找得到就好）。在需要高亮的html文件里面导入刚刚生成的css文件，例如我的是<link type=\"text/css\" rel=\"stylesheet\" href=\"{{ STATIC_URL }}styles/code.css\"/>。\r\n\r\n5.还记得刚刚代码里面的post.content = markdown(post.content) 吧，在后面加上[\'codehilite\']，即为post.content = markdown(post.content,[\'codehilite\'])。\r\n\r\n6.刷新前台，显示代码已经高亮。\r\n\r\n7.完','2018-01-27 09:41:32.279038','2018-03-08 10:23:26.954900','p','',27,10,'/upload/SelfieCity_20170101151755_save.jpg',0,2,1,'r'),(4,'程序员如何修复婚姻的bug','物学家 John Medina，也是《大脑规则（Brain Rules）》一书的作者，常常被问及该如何做好一个父亲，他的回答出人意料又发人深省。\r\n\r\n最近在 Hacker News 上，看到一家网络咨询公司的创始人 Tyler Ward 在 Relevant 杂志上发表的这篇《我希望我们在结婚前能知道的三件事》（3 Things I Wish I Knew Before We Got Married）的文章，让我想到许多程序员在自己所著的书里面往往会写上的那句话：献给我的妻子，原谅我没有花太多时间照顾你和孩子们。这句话听来让人 鼻翼一酸，五味杂陈。\r\n\r\n程序员的情感生活就像中国人的言论自由一样，充满着理想主义的色彩。 在谈及程序员的婚姻和爱情的时候，无数的程序员没等对方开口就已经将自己自嘲了一遍，似乎婚姻对程序员来说是个奢侈品。\r\n\r\n然而，不管如何，大多数的程序员最后还是会步入婚姻的殿堂，养个一儿半女。实际上大部分的已婚男士，特别是程序员，在婚后都会面临一系列家庭和事业 无法兼顾的问题，Tyler Ward 也毫不例外。但他在这个磨合的过程中收获了很多，也总结了一些自己的心得体会。他认为，在我们决定结婚之前，一定要清楚下面三件事情：\r\n\r\n结婚并不意味着以后都会过得很开心\r\n很多人对婚姻抱有过多的幻想，以为婚后的生活一定会令人兴奋，充满乐趣，毕竟生活里面将多一个人，想想都觉得温暖。虽然程序员整天在各种社交媒体里面自嘲屌丝，觉得爱情都是属于白富美和高富帅。甚至有人将程序员和女博士归为除了男人和女人之外的第三种和第四种人。但对于大多数对爱情充满期待而且又幸运地被爱情砸中的人来说，结婚是个神圣又诱人的词汇。对程序员来说，也是如此。\r\n\r\nTyler Ward 说自己当初结婚也是因为觉得生活里面不能没有她，所以向她求婚了。然而，婚后的他坦言，生活中没有任何事情能比她妻子更令他烦躁、沮丧和愤懑，因为在他认为自己已经尽力了的时候，她还提出各种各样的请求，最要命的是，这些请求都是合理的。\r\n\r\n后来，在阅读的过程中，他明白了一件事情，幸福不是婚姻的唯一目标。婚姻似火，最大的意义在于让我们体验不一样的生活，逼着我们前进，让我们收获成长。\r\n\r\n你在婚姻上付出越多，它给你的回报也越多\r\n这是个缺乏安全感的时代。尤其是科技日新月异给我们带来了许多恐慌，几乎每个上进的人都恨不得一天能有四十八个小时。为了能在这个竞争激烈的社会里面寻求一点生机，占得一席之地。有志青年往往将事业置于最重要的位置，甚至不允许其他任何事情凌驾之上。\r\n\r\n更让一向崇尚理性思维的程序员担心的是，大量的时间耗费在感情上，无疑是慢性自杀的行为。他们当中很多人的观点是， 先事业后感情，先工作后享受生活。这是他们做产品的思路：先发布产品，然后再慢慢迭代开发，完善其他的功能（即老婆孩子）。\r\n\r\n然而，但凡程序员都知道，解决问题有一种方法，叫逆推。既然我们最终的目标都是为了老婆孩子，为了享受生活，我们何不从一开始就先搞定妻子？如果我们把妻子优先考虑的话，感情 bug 能不能得到修复呢？\r\n\r\n在与诸多好友交流婚姻生活的冷暖，并探讨如何让婚姻生活更美好的时候，Tyler Ward 和他的朋友们几乎达成了一致的观点：如果一个人优先考虑他或她的另一半，生活中的其他方方面面都会因此受益。\r\n\r\n“当我们让婚姻享有它应该享受的优先级待遇的时候，它会变成一笔巨大的财富渗透到我们生活中的其他层面。”\r\n\r\nTyler Ward 分享了自己的真切感受，当他在一段时间里将妻子的所有事情都优先考虑的时候，他发现妻子前所未有的知书达理，甚至常常督促他专注自己的事业。她不再觉得他们的感情和他的事业追求是一对矛盾体，反倒觉得她自己是丈夫事业上的好伙伴。\r\n\r\n“我得到了我生活中最亲密的人的拥护，这让我受益匪浅。”\r\n\r\n婚姻可以改变世界\r\n回到开篇时候那个问答。生物学家 John Medina 向我们揭示了一个道理：婚姻绝不仅仅是让两个人过得更开心。婚姻将深刻并且非常直接地影响家庭当中的每个成员，甚至影响我们的文化。这个世界，我们的文 化，都是由一个个微小的家庭单元构成的，而婚姻是一个家庭能产生的最先决条件。\r\n\r\n在这个充斥着浮躁和不安的时代，在这个诗人逐渐死去的时代，人们已经没有多少浪漫情怀。程序员这个日益庞大的群体，也面临着越来越大的情感压力。或许，你的 妻子有时候并不是期许你每个月给支付宝上充值，而是希望你关上电脑，离开代码，陪她去看一场《北京遇上西雅图》或者，仅仅是陪她逛逛街，哪怕什么都不买。\r\n\r\n正如 Tyler Ward 所说，“如果你梦想着生活得与众不同，或者要想要在事业上获得巨大的成功，或者让自己成为一个更好的人，记着做这么一件事情：回家爱你的妻子，或者回家爱你的丈夫。”','2018-01-27 09:41:56.590669','2018-03-08 10:10:10.745168','p','',46,0,'',0,1,7,'r'),(5,'Django QuerySet API文档','在查询时发生了什么(When QuerySets are evaluated)\r\nQuerySet 可以被构造，过滤，切片，做为参数传递，这些行为都不会对数据库进行操作。只要你查询的时候才真正的操作数据库。\r\n\r\n下面的 QuerySet 行为会导致执行查询的操作：\r\n\r\n循环(Iteration)：QuerySet 是可迭代的，在你遍历对象时就会执行数据库操作。例如，打印出所有博文的大标题：\r\n\r\n1\r\n2\r\nfor e in Entry.objects.all():\r\n    print(e.headline)\r\n切片(Slicing)： QuerySet 是可以用 Python 的数组切片语法完成切片。一般来说对一个未查询的 QuerySet 切片就返回另一个未查询的 QuerySet (新 QuerySet 不会被执行)。不过如果你在切片时使用了 \"step\" 参数，Django 仍会执行数据库操作并且返回列表对象。对一个查询过的QuerySet执行切片也会返回列表对象。\r\n\r\n序列化／缓存化(Pickling/Caching)： 详情请查看 pickling QuerySets。 这一节所强调的一点是查询结果是从数据库中读取的。\r\n\r\nrepr(). 调用 QuerySet 的 repr() 方法时，查询就会被运行。这对于 Python 命令行来说非常方便，你可以使用 API 立即看到查询结果。\r\n\r\nlen(). 调用 QuerySet 的 len() 方法，查询就会被运行。这正如你所料，会返回查询结果列表的长度。\r\n\r\n注意：如果你想得到集合中记录的数量，就不要使用 QuerySet 的 len() 方法。因为直接在数据库层面使用 SQL 的 SELECT COUNT(*) 会更加高效，Django 提供了 count() 方法就是这个原因。详情参阅下面的 count() 方法。\r\n\r\nlist(). 对 QuerySet 应用 list() 方法，就会运行查询。例如：\r\n\r\n1\r\nentry_list = list(Entry.objects.all())\r\n要注意地是：使用这个方法会占用大量内存，因为 Django 将列表内容都载入到内存中。做为对比，遍历 QuerySet 是从数据库读取数据，仅在使用某个对象时才将其载入到内容中。\r\n\r\nPickling QuerySets\r\n\r\n如果你要 序列化(pickle) 一个 QuerySet，Django 首先就会将查询对象载入到内存中以完成序列化，这样你就可以第一时间使用对象(直接从数据库中读取数据需要一定时间，这正是缓存所想避免的)。而序列化是缓存化的先行工作，所以在缓存查询时，首先就会进行序列化工作。这意味着当你反序列化 QuerySet 时，第一时间就会从内存中获得查询的结果，而不是从数据库中查找。\r\n\r\n如果你只是想序列化部分必要的信息以便晚些时候可以从数据库中重建 Queryset ，那只序列化 QuerySet 的 query 属性即可。接下来你就可以使用下面的代码重建原来的 QuerySet （这当中没有数据库读取）：\r\n\r\n1\r\n2\r\n3\r\n4\r\n>>> import pickle\r\n>>> query = pickle.loads(s)     # Assuming \'s\' is the pickled string.\r\n>>> qs = MyModel.objects.all()\r\n>>> qs.query = query            # Restore the original \'query\'.\r\nquery 属性是一个不透明的对象。这就意味着它的内部结构并不是公开的。即便如此，对于本节提到的序列化和反序列化来说，它仍是安全和被完全支持的。\r\n\r\n查询API(QuerySet API)\r\nfilter(**kwargs)\r\n\r\n返回一个新的 QuerySet ，它包含了与所给的筛选条件相匹配的对象。\r\n\r\n这些筛选条件(**kwargs)在下面的字段筛选(Field lookups) 中有详细介绍。多个条件之间在 SQL 语句中是 AND 关系。\r\n\r\nexclude(**kwargs)\r\n\r\n返回一个新的 QuerySet，它包含那些与所给筛选条件不匹配的对象。\r\n\r\n这些筛选条件(**kwargs)也在下面的 字段筛选(Field lookups) 中有详细描述。多个条件之间在 SQL 语句中也是 AND 关系，但是整体又是一个 NOT() 关系。\r\n\r\n下面的例子剔除了出版日期 pub_date 晚于 2005-1-3 并且大标题 headline 是 \"Hello\" 的所有博文(entry)：\r\n\r\n1\r\nEntry.objects.exclude(pub_date__gt=datetime.date(2005, 1, 3), headline=\'Hello\')\r\n在 SQL 语句中，这等价于：\r\n\r\n1\r\n2\r\nSELECT ...\r\nWHERE NOT (pub_date > \'2005-1-3\' AND headline = \'Hello\')\r\n下面的例子剔除出版日期 pub_date 晚于 2005-1-3 或者大标题是 \"Hello\" 的所有博文：\r\n\r\n1\r\nEntry.objects.exclude(pub_date__gt=datetime.date(2005, 1, 3)).exclude(headline=\'Hello\')\r\n在 SQL 语句中，这等价于：\r\n\r\n1\r\n2\r\n3\r\nSELECT ...\r\nWHERE NOT pub_date > \'2005-1-3\'\r\nOR NOT headline = \'Hello\'\r\n要注意第二个例子是有很多限制的。\r\n\r\nannotate(*args, **kwargs)\r\n\r\n我们可以为 QuerySet 中的每个对象添加注解。可以通过计算查询结果中每个对象所关联的对象集合，从而得出总计值(也可以是平均值或总和，等等)，做为 QuerySet 中对象的注解。annotate() 中的每个参数都会被做为注解添加到 QuerySet 中返回的对象。\r\n\r\nDjango 提供的注解函式在下面的 (注解函式Aggregation Functions) 有详细介绍。\r\n\r\n注解会使用关键字参数来做为注解的别名。其中任何参数都会生成一个别名，它与注解函式的名称和被注解的 model 相关。\r\n\r\n例如，你正在操作一个博客列表，你想知道一个博客究竟有多少篇博文：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n>>> from django.db.models import Count\r\n>>> q = Blog.objects.annotate(Count(\'entry\'))\r\n# The name of the first blog\r\n>>> q[0].name\r\n\'Blogasaurus\'\r\n# The number of entries on the first blog\r\n>>> q[0].entry__count\r\n42\r\nBlog model 类本身并没有定义 entry__count 属性，但可以使用注解函式的关系字参数，从而改变注解的命名：\r\n\r\n1\r\n2\r\n3\r\n4\r\n>>> q = Blog.objects.annotate(number_of_entries=Count(\'entry\'))\r\n# The number of entries on the first blog, using the name provided\r\n>>> q[0].number_of_entries\r\n42\r\norder_by(*fields)\r\n\r\n默认情况下， QuerySet 返回的查询结果是根据 model 类的 Meta 设置所提供的 ordering 项中定义的排序元组来进行对象排序的。你可以使用 order_by 方法覆盖之前 QuerySet 中的排序设置。\r\n\r\n例如：\r\n\r\n1\r\nEntry.objects.filter(pub_date__year=2005).order_by(\'-pub_date\', \'headline\')\r\n返回结果就会先按照 pub_date 进行升序排序，再按照 headline 进行降序排序。 \"-pub_date\" 前面的负号\"-\"表示降序排序。默认是采用升序排序。要随机排序，就使用 \"?\"，例如：\r\n\r\n1\r\nEntry.objects.order_by(\'?\')\r\n注意：order_by(\'?\') 可能会非常缓慢和消耗过多资源，这取决于你所使用的数据库。\r\n\r\n要根据其他 model 字段排序，所用语法和跨关系查询的语法相同。就是说，用两个连续的下划线(__)连接关联 model 和 要排序的字段名称, 而且可以一直延伸。例如：\r\n\r\n1\r\nEntry.objects.order_by(\'blog__name\', \'headline\')\r\n如果你想对关联字段排序，在没有指定 Meta.ordering 的情况下，Django 会采用默认排序设置，就是按照关联 model 的主键进行排序。例如：\r\n\r\n1\r\nEntry.objects.order_by(\'blog\')\r\n等价于：\r\n\r\n1\r\nEntry.objects.order_by(\'blog__id\')\r\n这是因为 Blog model 没有声明排序项的原故。\r\n\r\nDjango 1.7新添加：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n# No Join\r\nEntry.objects.order_by(\'blog_id\')     #可以避免JOIN的代价\r\n \r\n# Join\r\nEntry.objects.order_by(\'blog__id\')\r\n如果你使用了 distinct() 方法，那么在对关联字段排序时要格外谨慎。\r\n\r\n在 Django 当中是可以按照多值字段（例如 ManyToMany 字段）进行排序的。不过，这个特性虽然先进，但是并不实用。除非是你已经很清楚过滤结果或可用数据中的每个对象，都只有一个相关联的对象时（就是相当于只是一对一关系时），排序才会符合你预期的结果，所以对多值字段排序时要格外注意。\r\n\r\n如果你不想对任何字段排序，也不想使用 model 中原有的排序设置，那么可以调用无参数的 order_by() 方法。\r\n\r\n对于排序项是否应该大小写敏感，Django 并没有提供设置方法，这完全取决于后端的数据库对排序大小写如何处理。\r\n\r\n你可以令某个查询结果是可排序的，也可以是不可排序的，这取决于 QuerySet.ordered 属性。如果它的值是 True ，那么 QuerySet 就是可排序的。\r\n\r\nreverse()\r\n\r\n使用 reverse() 方法会对查询结果进行反向排序。调用两次 reverse() 方法相当于排序没发生改过。\r\n\r\n要得到查询结果中最后五个对象，可以这样写：\r\n\r\n1\r\nmy_queryset.reverse()[:5]\r\n要注意这种方式与 Python 语法中的从尾部切片是完全不一样的。在上面的例子中，是先得到最后一个元素，然后是倒数第二个，依次处理。但是如果我们有一个 Python 队列，使用 seq[-5:]时，却是先得到倒数第五个元素。Django 之所以采用 reverse 来获取倒数的记录，而不支持切片的方法，原因就是后者在 SQL 中难以做好。\r\n\r\n还有一点要注意，就是 reverse() 方法应该只作用于已定义了排序项 QuerySet (例如，在查询时使用了order_by()方法，或是在 model 类当中直接定义了排序项). 如果并没有明确定义排序项，那么调用 QuerySet, calling reverse() 就没什么实际意义（因为在调用 reverse() 之前，数据没有定义排序，所以在这之后也不会进行排序。)\r\n\r\ndistinct()\r\n\r\n返回一个新的 QuerySet ，它会在执行 SQL 查询时使用 SELECT DISTINCT。这意味着返回结果中的重复记录将被剔除。\r\n\r\n默认情况下， QuerySet 并会剔除重复的记录。在实际当中，这不是什么问题，因为象 Blog.objects.all() 这样的查询并不会产生重复的记录。但是，如果你使用 QuerySet 做多表查询时，就很可能会产生重复记录。这时，就可以使用 distinct() 方法。\r\n\r\nNote\r\n\r\n在 order_by(*fields) 中出现的字段也会包含在 SQL SELECT 列中。如果和 distinct() 同时使用，有时返回的结果却与预想的不同。这是因为：如果你对跨关系的关联字段进行排序，这些字段就会被添加到被选取的列中，这就可能产生重复数据（比如，其他的列数据都相同，只是关联字段的值不同）。但由于 order_by 中的关联字段并不会出现在返回结果中（他们仅仅是用来实现order），所以有时返回的数据看上去就象是并没有进行过 distinct 处理一样。\r\n\r\n同样的原因，如果你用 values() 方法获得被选取的列，就会发现包含在 order_by() (或是 model 类的 Meta 中设置的排序项)中的字段也包含在里面，就会对返回的结果产生影响。\r\n\r\n这章节强调的就是在你使用 distinct() 时，要谨慎对待关联字段排序。同样的，在同时使用 distinct() 和 values() 时，如果排序字段并没有出现在 values() 返回的结果中，那么也要引起注意。\r\n\r\nvalues(*fields)\r\n\r\n返回一个 ValuesQuerySet ----一个特殊的 QuerySet ，运行后得到的并不是一系列 model 的实例化对象，而是一个可迭代的字典序列。\r\n\r\n每个字典都表示一个对象，而键名就是 model 对象的属性名称。\r\n\r\n下面的例子就对 values() 得到的字典与传统的 model 对象进行了对比：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n# This list contains a Blog object.\r\n>>> Blog.objects.filter(name__startswith=\'Beatles\')\r\n[<Blog: Beatles Blog>]\r\n \r\n# This list contains a dictionary.\r\n>>> Blog.objects.filter(name__startswith=\'Beatles\').values()\r\n[{\'id\': 1, \'name\': \'Beatles Blog\', \'tagline\': \'All the latest Beatles news.\'}]\r\nvalues() 可以接收可选的位置参数，*fields，就是字段的名称，用来限制 SELECT 选取的数据。如果你指定了字段参数，每个字典就会以 Key-Value 的形式保存你所指定的字段信息；如果没有指定，每个字典就会包含当前数据表当中的所有字段信息。\r\n\r\n例如：\r\n\r\n1\r\n2\r\n3\r\n4\r\n>>> Blog.objects.values()\r\n[{\'id\': 1, \'name\': \'Beatles Blog\', \'tagline\': \'All the latest Beatles news.\'}],\r\n>>> Blog.objects.values(\'id\', \'name\')\r\n[{\'id\': 1, \'name\': \'Beatles Blog\'}]\r\n下面这些细节值得注意：\r\n\r\n    如果你有一个名为 foo 的ForeignKey 字段，默认情况下调用 values() 返回的字典中包含键名为 foo_id 的字典项，因为它是一个隐含的 model 字段，用来保存关联对象的主键值( foo 属性用来联系相关联的 model )。当你使用 values() 并传递字段名称时， 传递foo 或 foo_id 都会得到相同的结果 (字典中的键名会自动换成你传递的字段名称)。\r\n\r\n例如：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n>>> Entry.objects.values()\r\n[{\'blog_id\': 1, \'headline\': u\'First Entry\', ...}, ...]\r\n \r\n>>> Entry.objects.values(\'blog\')\r\n[{\'blog\': 1}, ...]\r\n \r\n>>> Entry.objects.values(\'blog_id\')\r\n[{\'blog_id\': 1}, ...]\r\n    在 values() 和 distinct() 同时使用时，要注意排序项会影响返回的结果，详情请查看上面 distinct() 一节。\r\n\r\n    在values()之后使用defer()和only()是无用的。\r\n\r\nValuesQuerySet 是非常有用的。利用它，你就可以只获得你所需的那部分数据，而不必同时读取其他的无用数据。\r\n\r\n最后，要提醒的是，ValuesQuerySet 是 QuerySet 的一个子类，所以它拥有 QuerySet 所有的方法。你可以对它调用 filter() 或是 order_by() 以及其他方法。所以下面俩种写法是等价的：\r\n\r\n1\r\n2\r\nBlog.objects.values().order_by(\'id\')\r\nBlog.objects.order_by(\'id\').values()\r\nDjango 的编写者们更喜欢第二种写法，就是先写影响 SQL 的方法，再写影响输出的方法（比如例中先写 order，再写values ），但这些都无关紧要，完全视你个人喜好而定。\r\n\r\n也可以指向一对一、多对多、外键关系对象的域：\r\n\r\n1\r\n2\r\n3\r\nBlog.objects.values(\'name\', \'entry__headline\')\r\n[{\'name\': \'My blog\', \'entry__headline\': \'An entry\'},\r\n     {\'name\': \'My blog\', \'entry__headline\': \'Another entry\'}, ...]\r\n当指向多对多关系时，因为关联对象可能有很多，所以同一个对象会根据不同的多对多关系返回多次。\r\n\r\nvalues_list(*fields)\r\n\r\n它与 values() 非常相似，只不过后者返回的结果是字典序列，而 values() 返回的结果是元组序列。每个元组都包含传递给 values_list() 的字段名称和内容。比如第一项就对应着第一个字段，例如：\r\n\r\n1\r\n2\r\n>>> Entry.objects.values_list(\'id\', \'headline\')\r\n[(1, u\'First entry\'), ...]\r\n如果你传递了一个字段做为参数，那么你可以使用 flat 参数。如果它的值是 True，就意味着返回结果都是单独的值，而不是元组。下面的例子会讲得更清楚：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n>>> Entry.objects.values_list(\'id\').order_by(\'id\')\r\n[(1,), (2,), (3,), ...]\r\n \r\n>>> Entry.objects.values_list(\'id\', flat=True).order_by(\'id\')\r\n[1, 2, 3, ...]\r\n如果传递的字段不止一个，使用 flat 就会导致错误。\r\n\r\n如果你没给 values_list() 传递参数，它就会按照字段在 model 类中定义的顺序返回所有的字段。\r\n\r\n注意这个方法返回的是 ValuesListQuerySet对象，和列表相似但并不是列表，需要列表操作时需list()转为列表。\r\n\r\ndates(field, kind, order=\'ASC\')\r\n\r\n返回一个 DateQuerySet ，就是提取 QuerySet 查询中所包含的日期，将其组成一个新的 datetime.date 对象的列表。\r\n\r\nfield 是你的 model 中的 DateField 字段名称。\r\n\r\nkind 是 \"year\", \"month\" 或 \"day\" 之一。 每个 datetime.date对象都会根据所给的 type 进行截减。\r\n\r\n\"year\" 返回所有时间值中非重复的年分列表。\r\n\"month\" 返回所有时间值中非重复的年／月列表。\r\n\"day\" 返回所有时间值中非重复的年／月／日列表。\r\norder, 默认是 \'ASC\'，只有两个取值 \'ASC\' 或 \'DESC\'。它决定结果如何排序。\r\n\r\n例子：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n>>> Entry.objects.dates(\'pub_date\', \'year\')\r\n[datetime.date(2005, 1, 1)]\r\n>>> Entry.objects.dates(\'pub_date\', \'month\')\r\n[datetime.date(2005, 2, 1), datetime.date(2005, 3, 1)]\r\n>>> Entry.objects.dates(\'pub_date\', \'day\')\r\n[datetime.date(2005, 2, 20), datetime.date(2005, 3, 20)]\r\n>>> Entry.objects.dates(\'pub_date\', \'day\', order=\'DESC\')\r\n[datetime.date(2005, 3, 20), datetime.date(2005, 2, 20)]\r\n>>> Entry.objects.filter(headline__contains=\'Lennon\').dates(\'pub_date\', \'day\')\r\n[datetime.date(2005, 3, 20)]\r\ndatetimes(field, kind, order=\'ASC\')\r\n\r\n返回一个 DateTimeQuerySet ，就是提取 QuerySet 查询中所包含的日期，将其组成一个新的 datetime.datetime 对象的列表。\r\n\r\nnone()\r\n\r\n返回一个 EmptyQuerySet -- 它是一个运行时只返回空列表的 QuerySet。它经常用在这种场合：你要返回一个空列表，但是调用者却需要接收一个 QuerySet 对象。（这时，就可以用它代替空列表）\r\n\r\n例如：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n>>> Entry.objects.none()\r\n[]\r\n>>> from django.db.models.query import EmptyQuerySet\r\n>>> isinstance(Entry.objects.none(), EmptyQuerySet)\r\nTrue\r\nall()\r\n\r\n返回当前 QuerySet (或者是传递的 QuerySet 子类)的一分拷贝。 这在某些场合是很用的，比如，你想对一个 model manager 或是一个 QuerySet 的查询结果做进一步的过滤。你就可以调用 all() 获得一分拷贝以继续操作，从而保证原 QuerySet 的安全。\r\n\r\n当一个QuerySet查询后，它会缓存查询结果。如果数据库发生了改变，就可以调用all()来更新查询过的QuerySet。\r\n\r\nselect_related()\r\n\r\n返回一个 QuerySet ，它会在执行查询时自动跟踪外键关系，从而选取所关联的对象数据。它是一个增效器，虽然会导致较大的数据查询（有时会非常大），但是接下来再使用外键关系获得关联对象时，就会不再次读取数据库了。\r\n\r\n下面的例子展示在获得关联对象时，使用 select_related() 和不使用的区别，首先是不使用的例子：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n# Hits the database.\r\ne = Entry.objects.get(id=5)\r\n \r\n# Hits the database again to get the related Blog object.\r\nb = e.blog\r\n接下来是使用 select_related 的例子：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n# Hits the database.\r\ne = Entry.objects.select_related().get(id=5)\r\n \r\n# Doesn\'t hit the database, because e.blog has been prepopulated\r\n# in the previous query.\r\nb = e.blog\r\nselect_related() 会尽可能地深入遍历外键连接。例如：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\nfrom django.db import models\r\n \r\nclass City(models.Model):\r\n    # ...\r\n    pass\r\n \r\nclass Person(models.Model):\r\n    # ...\r\n    hometown = models.ForeignKey(City)\r\n \r\nclass Book(models.Model):\r\n    # ...\r\n    author = models.ForeignKey(Person)\r\n 接下来调用 Book.objects.select_related().get(id=4) 将缓存关联的 Person 和 City：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\nb = Book.objects.select_related(\'person__city\').get(id=4)\r\np = b.author         # Doesn\'t hit the database.\r\nc = p.hometown       # Doesn\'t hit the database.\r\n \r\nb = Book.objects.get(id=4) # No select_related() in this example.\r\np = b.author         # Hits the database.\r\nc = p.hometown       # Hits the database.\r\nprefetch_related()\r\n\r\n对于多对多字段（ManyToManyField）和一对多字段，可以使用prefetch_related()来进行优化。或许你会说，没有一个叫OneToManyField的东西啊。实际上 ，ForeignKey就是一个多对一的字段，而被ForeignKey关联的字段就是一对多字段了。\r\n\r\nprefetch_related()和select_related()的设计目的很相似，都是为了减少SQL查询的数量，但是实现的方式不一样。后者是通过JOIN语句，在SQL查询内解决问题。但是对于多对多关系，使用SQL语句解决就显得有些不太明智，因为JOIN得到的表将会很长，会导致SQL语句运行时间的增加和内存占用的增加。若有n个对象，每个对象的多对多字段对应Mi条，就会生成Σ(n)Mi 行的结果表。\r\n\r\nprefetch_related()的解决方法是，分别查询每个表，然后用Python处理他们之间的关系。\r\n\r\n 例如：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\nfrom django.db import models\r\n \r\nclass Topping(models.Model):\r\n    name = models.CharField(max_length=30)\r\n \r\nclass Pizza(models.Model):\r\n    name = models.CharField(max_length=50)\r\n    toppings = models.ManyToManyField(Topping)\r\n \r\n    def __str__(self):              # __unicode__ on Python 2\r\n        return \"%s (%s)\" % (self.name, \", \".join([topping.name\r\n                                                  for topping in self.toppings.all()]))\r\n运行\r\n\r\n1\r\n>>> Pizza.objects.all().prefetch_related(\'toppings\')\r\n可以联合查询：\r\n\r\n1\r\n2\r\n3\r\nclass Restaurant(models.Model):\r\n    pizzas = models.ManyToMany(Pizza, related_name=\'restaurants\')\r\n    best_pizza = models.ForeignKey(Pizza, related_name=\'championed_by\')\r\n下面的例子都可以\r\n\r\n1\r\n2\r\n3\r\n>>> Restaurant.objects.prefetch_related(\'pizzas__toppings\')\r\n>>> Restaurant.objects.prefetch_related(\'best_pizza__toppings\')\r\n>>> Restaurant.objects.select_related(\'best_pizza\').prefetch_related(\'best_pizza__toppings\')　　\r\nextra(select=None, where=None, params=None, tables=None, order_by=None, select_params=None)\r\n\r\n有些情况下，Django 的查询语法难以简练地表达复杂的 WHERE 子句。对于这种情况，Django 提供了 extra() QuerySet 修改机制，它能在QuerySet 生成的 SQL 从句中注入新子句。\r\n\r\n由于产品差异的原因，这些自定义的查询难以保障在不同的数据库之间兼容(因为你手写 SQL 代码的原因)，而且违背了 DRY 原则，所以如非必要，还是尽量避免写 extra。\r\n\r\n在 extra 可以指定一个或多个 params 参数，如 select，where 或 tables。所有参数都是可选的，但你至少要使用一个。\r\n\r\n   select\r\nselect 参数可以让你在 SELECT 从句中添加其他字段信息。它应该是一个字典，存放着属性名到 SQL 从句的映射。\r\n\r\n例如：\r\n\r\n1\r\nEntry.objects.extra(select={\'is_recent\': \"pub_date > \'2006-01-01\'\"})\r\n结果中每个 Entry 对象都有一个额外的 is_recent 属性，它是一个布尔值，表示 pub_date 是否晚于2006年1月1号。\r\n\r\nDjango 会直接在 SELECT 中加入对应的 SQL 片断，所以转换后的 SQL 如下：\r\n\r\n1\r\n2\r\nSELECT blog_entry.*, (pub_date > \'2006-01-01\')\r\nFROM blog_entry;\r\n下面这个例子更复杂一些；它会在每个 Blog 对象中添加一个 entry_count 属性，它会运行一个子查询，得到相关联的 Entry 对象的数量：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\nBlog.objects.extra(\r\nselect={\r\n\'entry_count\': \'SELECT COUNT(*) FROM blog_entry WHERE blog_entry.blog_id = blog_blog.id\'\r\n},\r\n)\r\n(在上面这个特例中，我们要了解这个事实，就是 blog_blog 表已经存在于 FROM 从句中。)\r\n\r\n翻译成 SQL 如下：\r\n\r\n1\r\n2\r\nSELECT blog_blog.*, (SELECT COUNT(*) FROM blog_entry WHERE blog_entry.blog_id = blog_blog.id) AS entry_count\r\nFROM blog_blog;\r\n要注意的是，大多数数据库需要在子句两端添加括号，而在 Django 的 select 从句中却无须这样。同样要引起注意的是，在某些数据库中，比如某些 MySQL 版本，是不支持子查询的。\r\n\r\n某些时候，你可能想给 extra(select=...) 中的 SQL 语句传递参数，这时就可以使用 select_params 参数。因为 select_params 是一个队列，而 select 属性是一个字典，所以两者在匹配时应正确地一一对应。在这种情况下中，你应该使用 django.utils.datastructures.SortedDict 匹配 select 的值，而不是使用一般的 Python 队列。\r\n\r\n例如：\r\n\r\n1\r\n2\r\n3\r\nBlog.objects.extra(\r\nselect=SortedDict([(\'a\', \'%s\'), (\'b\', \'%s\')]),\r\nselect_params=(\'one\', \'two\'))\r\n在使用 extra() 时要避免在 select 字串含有 \"%%s\" 子串， 这是因为在 Django 中，处理 select 字串时查找的是 %s 而并非转义后的 % 字符。所以如果对 % 进行了转义，反而得不到正确的结果。\r\n\r\n   where / tables\r\n你可以使用 where 参数显示定义 SQL 中的 WHERE 从句，有时也可以运行非显式地连接。你还可以使用 tables 手动地给 SQL FROM 从句添加其他表。\r\n\r\nwhere 和 tables 都接受字符串列表做为参数。所有的 where 参数彼此之间都是 \"AND\" 关系。\r\n\r\n例如：\r\n\r\n1\r\nEntry.objects.extra(where=[\'id IN (3, 4, 5, 20)\'])\r\n大致可以翻译为如下的 SQL:\r\n\r\n1\r\nSELECT * FROM blog_entry WHERE id IN (3, 4, 5, 20);\r\n在使用 tables 时，如果你指定的表在查询中已出现过，那么要格外小心。当你通过 tables 参数添加其他数据表时，如果这个表已经被包含在查询中，那么 Django 就会认为你想再一次包含这个表。这就导致了一个问题：由于重复出现多次的表会被赋予一个别名，所以除了第一次之外，每个重复的表名都会分别由 Django 分配一个别名。所以，如果你同时使用了 where 参数，在其中用到了某个重复表，却不知它的别名，那么就会导致错误。\r\n\r\n一般情况下，你只会添加一个未在查询中出现的新表。但是如果上面所提到的特殊情况发生了，那么可以采用如下措施解决。首先，判断是否有必要要出现重复的表，能否将重复的表去掉。如果这点行不通，就试着把 extra() 调用放在查询结构的起始处，因为首次出现的表名不会被重命名，所以可能能解决问题。如果这也不行，那就查看生成的 SQL 语句，从中找出各个数据库的别名，然后依此重写 where 参数，因为只要你每次都用同样的方式调用查询(queryset)，表的别名都不会发生变化。所以你可以直接使用表的别名来构造 where。\r\n\r\n   order_by\r\n如果你已通过 extra() 添加了新字段或是数据库，此时若想对新字段进行排序，就可以给 extra() 中的 order_by 参数传递一个排序字符串序列。字符串可以是 model 原生的字段名(与使用普通的 order_by() 方法一样)，也可以是 table_name.column_name 这种形式，或者是你在 extra() 的 select 中所定义的字段。\r\n\r\n例如：\r\n\r\n1\r\n2\r\nq = Entry.objects.extra(select={\'is_recent\': \"pub_date > \'2006-01-01\'\"})\r\nq = q.extra(order_by = [\'-is_recent\'])\r\n这段代码按照 is_recent 对记录进行排序，字段值是 True 的排在前面，False 的排在后面。(True 在降序排序时是排在 False 的前面)。\r\n\r\n顺便说一下，上面这段代码同时也展示出，可以依你所愿的那样多次调用 extra() 操作(每次添加新的语句结构即可)。\r\n\r\n    params\r\n上面提到的 where 参数还可以用标准的 Python 占位符 -- \'%s\' ，它可以根据数据库引擎自动决定是否添加引号。 params 参数是用来替换占位符的字符串列表。\r\n\r\n例如：\r\n\r\n1\r\nEntry.objects.extra(where=[\'headline=%s\'], params=[\'Lennon\'])\r\n使用 params 替换 where 的中嵌入值是一个非常好的做法，这是因为 params 可以根据你的数据库判断要不要给传入值添加引号（例如，传入值中的引号会被自动转义）。\r\n\r\n不好的用法：\r\n\r\n1\r\nEntry.objects.extra(where=[\"headline=\'Lennon\'\"])\r\n优雅的用法：\r\n\r\n1\r\nEntry.objects.extra(where=[\'headline=%s\'], params=[\'Lennon\'])\r\ndefer(*fields)\r\n\r\n在某些数据复杂的环境下，你的 model 可能包含非常多的字段，可能某些字段包含非常多的数据(比如，文档字段)，或者将其转化为 Python 对象会消耗非常多的资源。在这种情况下，有时你可能并不需要这种字段的信息，那么你可以让 Django 不读取它们的数据。\r\n\r\n将不想载入的字段的名称传给 defer() 方法，就可以做到延后载入：\r\n\r\n1\r\nEntry.objects.defer(\"lede\", \"body\")\r\n延后截入字段的查询返回的仍是 model 类的实例。在你访问延后载入字段时，你仍可以获得字段的内容，所不同的是，内容是在你访问延后字段时才读取数据库的，而普通字段是在运行查询(queryset)时就一次性从数据库中读取数据的。\r\n\r\n你可以多次调用 defer() 方法。每个调用都可以添加新的延后载入字段：\r\n\r\n1\r\n2\r\n# Defers both the body and lede fields.\r\nEntry.objects.defer(\"body\").filter(headline=\"Lennon\").defer(\"lede\")\r\n对延后载入字段进行排序是不会起作用的；重复添加延后载入字段也不会有何不良影响。\r\n\r\n你也可以延后载入关联 model 中的字段(前提是你使用 select_related() 载入了关联 model)，用法也是用双下划线连接关联字段：\r\n\r\n1\r\nBlog.objects.select_related().defer(\"entry__lede\", \"entry__body\")\r\n如果你想清除延后载入的设置，只要使用将 None 做为参数传给 defer() 即可：\r\n\r\n1\r\n2\r\n# Load all fields immediately.\r\nmy_queryset.defer(None)\r\n有些字段无论你如何指定，都不会被延后加载。比如，你永远不能延后加载主键字段。如果你使用 select_related() 获得关联 model 字段信息，那么你就不能延后载入关联 model 的主键。（如果这样做了，虽然不会抛出错误，事实上却不完成延后加载）\r\n\r\nNote\r\n\r\ndefer() 方法(和随后提到的 only() 方法) 都只适用于特定情况下的高级属性。它们可以提供性能上的优化，不过前提是你已经对你用到的查询有过很深入细致的分析，非常清楚你需要的究竟是哪些信息，而且已经对你所需要的数据和默认情况下返回的所有数据进行比对，清楚两者之间的差异。这完成了上述工作之后，再使用这两种方法进行优化才是有意义的。所以当你刚开始构建你的应用时，先不要急着使用 defer() 方法，等你已经写完查询并且分析成哪些方面是热点应用以后，再用也不迟。\r\n\r\nonly(*fields)\r\n\r\nonly() 方法或多或少与 defer() 的作用相反。如果你在提取数据时希望某个字段不应该被延后载入，而应该立即载入，那么你就可以做使用 only() 方法。如果你一个 model ，你希望它所有的字段都延后加载，只有某几个字段是立即载入的，那么你就应该使用 only() 方法。\r\n\r\n如果你有一个 model，它有 name, age 和 biography 三个字段，那么下面两种写法效果一样的：\r\n\r\n1\r\n2\r\nPerson.objects.defer(\"age\", \"biography\")\r\nPerson.objects.only(\"name\")\r\n你无论何时调用 only()，它都会立刻更改载入设置。这与它的命名非常相符：只有 only 中的字段会立即载入，而其他的则都是延后载入的。因此，连续调用 only() 时，只有最后一个 only 方法才会生效：\r\n\r\n1\r\n2\r\n# This will defer all fields except the headline.\r\nEntry.objects.only(\"body\", \"lede\").only(\"headline\")\r\n由于 defer() 可以递增（每次都添加字段到延后载入的列表中），所以你可以将 only() 和 defer() 结合在一起使用，请注意使用顺序，先 only 而后 defer：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n# Final result is that everything except \"headline\" is deferred.\r\nEntry.objects.only(\"headline\", \"body\").defer(\"body\")\r\n \r\n# Final result loads headline and body immediately (only() replaces any\r\n# existing set of fields).\r\nEntry.objects.defer(\"body\").only(\"headline\", \"body\")\r\nusing(alias)\r\n\r\n使用多个数据库时使用，参数是数据库的alias\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n# queries the database with the \'default\' alias.\r\n>>> Entry.objects.all()\r\n \r\n# queries the database with the \'backup\' alias\r\n>>> Entry.objects.using(\'backup\')\r\nselect_for_update(nowait=False)\r\n\r\n返回queryset，并将需要更新的行锁定，类似于SELECT ... FOR UPDATE的操作。\r\n\r\n1\r\nentries = Entry.objects.select_for_update().filter(author=request.user)\r\n所有匹配的entries都会被锁定直到此次事务结束。\r\n\r\nraw(raw_query, params=None, translations=None)\r\n\r\n执行raw SQL queries\r\n\r\n不返回查询的方法(QuerySet methods that do not return QuerySets)\r\n下面所列的 QuerySet 方法作用于 QuerySet，却并不返回 other than a QuerySet。\r\n\r\n这些方法并不使用缓存(请查看 缓存与查询(Caching and QuerySets))。所以它们在运行时是立即读取数据库的。\r\n\r\nget(**kwargs)\r\n\r\n返回与所给的筛选条件相匹配的对象，筛选条件在 字段筛选条件(Field lookups) 一节中有详细介绍。\r\n\r\n在使用 get() 时，如果符合筛选条件的对象超过一个，就会抛出 MultipleObjectsReturned 异常。MultipleObjectsReturned 是 model 类的一个属性。\r\n\r\n在使用 get() 时，如果没有找到符合筛选条件的对象，就会抛出 DoesNotExist 异常。这个异常也是 model 对象的一个属性。例如：\r\n\r\n1\r\nEntry.objects.get(id=\'foo\') # raises Entry.DoesNotExist\r\nDoesNotExist 异常继承自 django.core.exceptions.ObjectDoesNotExist，所以你可以直接截获 DoesNotExist 异常。例如：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\nfrom django.core.exceptions import ObjectDoesNotExist\r\ntry:\r\n    e = Entry.objects.get(id=3)\r\n    b = Blog.objects.get(id=1)\r\nexcept ObjectDoesNotExist:\r\n    print(\"Either the entry or blog doesn\'t exist.\")\r\ncreate(**kwargs)\r\n\r\n创建对象并同时保存对象的快捷方法：\r\n\r\n1\r\np = Person.objects.create(first_name=\"Bruce\", last_name=\"Springsteen\")\r\n和\r\n\r\n1\r\n2\r\np = Person(first_name=\"Bruce\", last_name=\"Springsteen\")\r\np.save(force_insert=True)\r\n是相同的。\r\n\r\nforce_insert 参数在别处有详细介绍，它表示把当前 model 当成一个新对象来创建。一般情况下，你不必担心这一点，但是如果你的 model 的主键是你手动指定的，而且它的值已经在数据库中存在，那么调用 create() 就会失败，并抛出 IntegrityError。这是因为主键值必须是唯一的。所以当你手动指定主键时，记得要做好处理异常的准备。\r\n\r\nget_or_create(defaults=None,**kwargs)\r\n\r\n这是一个方便实际应用的方法，它根据所给的筛选条件查询对象，如果对象不存在就创建一个新对象。\r\n\r\n它返回的是一个 (object, created) 元组，其中的 object 是所读取或是创建的对象，而 created 则是一个布尔值，它表示前面提到的 object 是否是新创建的。\r\n\r\n这意味着它可以有效地减少代码，并且对编写数据导入脚本非常有用。例如：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\ntry:\r\n    obj = Person.objects.get(first_name=\'John\', last_name=\'Lennon\')\r\nexcept Person.DoesNotExist:\r\n    obj = Person(first_name=\'John\', last_name=\'Lennon\', birthday=date(1940, 10, 9))\r\n    obj.save()\r\n上面的代码会随着 model 中字段数量的激增而变得愈发庸肿。接下来用 get_or_create() 重写：\r\n\r\n1\r\n2\r\nobj, created = Person.objects.get_or_create(first_name=\'John\', last_name=\'Lennon\',\r\n                  defaults={\'birthday\': date(1940, 10, 9)})\r\n在这里要注意 defaults 是一个字典，它仅适用于创建对象时为字段赋值，而并不适用于查找已存在的对象。 get_or_create() 所接收的关键字参数都会在调用 get() 时被使用，有一个参数例外，就是 defaults。在使用get_or_create() 时如果找到了对象，就会返回这个对象和 False。如果没有找到，就会实例化一个新对象，并将其保存；同时返回这个新对象和 True。创建新对象的步骤大致如下：\r\n\r\n1\r\n2\r\n3\r\n4\r\nparams = dict([(k, v) for k, v in kwargs.items() if \'__\' not in k])\r\nparams.update(defaults)\r\nobj = self.model(**params)\r\nobj.save()\r\n用自然语言描述：从非 \'defaults\' 关键字参数中排除含有双下划线的参数（因为双下划线表示非精确查询），然后再添加 defaults 字典的内容，如果键名与已有的关键字参数重复，就以 defaults 中的内容为准, 然后将整理后的关键字参数传递给 model 类。当然，这只是算法的简化描述，实际上对很多细节没有提及，比如对异常和边界条件的处理。如果你对此感兴趣，不妨看一下原代码。\r\n\r\n如果你的 model 恰巧有一个字段，名称正是 defaults，而且你想在 get_or_create() 中用它做为精确查询的条件, 就得使用 \'defaults__exact\' (之前提过 defaults 只能在创建时对对象赋值，而不能进行查询)，象下面这样：\r\n\r\n1\r\nFoo.objects.get_or_create(defaults__exact=\'bar\', defaults={\'defaults\': \'baz\'})\r\n如果你手动指定了主键，那么使用 get_or_create() 方法时也会象 create() 一样，抛出类似的异常。当你手动指定了主键，若主键值已经在数据库中存在，就会抛出一个 IntegrityError 异常。\r\n\r\n最后提一下在 Django 视图(views)中使用 get_or_create() 时要注意的一点。如上所说，对于在脚本中分析数据和添加新数据而言，get_or_create() 是非常有用的。但是如果你是在视图中使用 get_or_create() ，那么就要格外留意，要确认是在 POST 请求中使用，除非你有很必要和很充分的理由才不这么做。而在 GET 请求中使用的话，不会对数据产生任何作用。而使用 POST 的话，每个发往页面的请求都会对数据有一定的副作用。\r\n\r\nNote\r\n\r\n通过多对多关系使用时要注意：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\nclass Chapter(models.Model):\r\n    title = models.CharField(max_length=255, unique=True)\r\n \r\nclass Book(models.Model):\r\n    title = models.CharField(max_length=256)\r\n    chapters = models.ManyToManyField(Chapter)\r\n运行：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n>>> book = Book.objects.create(title=\"Ulysses\")\r\n>>> book.chapters.get_or_create(title=\"Telemachus\")\r\n(<Chapter: Telemachus>, True)\r\n>>> book.chapters.get_or_create(title=\"Telemachus\")\r\n(<Chapter: Telemachus>, False)\r\n>>> Chapter.objects.create(title=\"Chapter 1\")\r\n<Chapter: Chapter 1>\r\n>>> book.chapters.get_or_create(title=\"Chapter 1\")\r\n# Raises IntegrityError\r\n不和book相关联的Chapter就不会被查找到了。\r\n\r\nupdate_or_create(defaults=None, **kwargs)\r\n\r\n与上面类似\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\ntry:\r\n    obj = Person.objects.get(first_name=\'John\', last_name=\'Lennon\')\r\n    for key, value in updated_values.iteritems():\r\n        setattr(obj, key, value)\r\n    obj.save()\r\nexcept Person.DoesNotExist:\r\n    updated_values.update({\'first_name\': \'John\', \'last_name\': \'Lennon\'})\r\n    obj = Person(**updated_values)\r\n    obj.save()\r\n可以简写为：\r\n\r\n1\r\n2\r\nobj, created = Person.objects.update_or_create(\r\n    first_name=\'John\', last_name=\'Lennon\', defaults=updated_values)\r\nbulk_create(objs, batch_size=None)\r\n\r\n批量创建\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n>>> Entry.objects.bulk_create([\r\n...     Entry(headline=\"Django 1.0 Released\"),\r\n...     Entry(headline=\"Django 1.1 Announced\"),\r\n...     Entry(headline=\"Breaking: Django is awesome\")\r\n... ])\r\n优于：\r\n\r\n1\r\n2\r\nEntry.objects.create（headline=\"Python 1.0 Released\"）\r\nEntry.objects.create（headline=\"Python 1.1 Planned\"）\r\ncount()\r\n\r\n返回数据库中匹配查询(QuerySet)的对象数量。 count() 不会抛出任何异常。\r\n\r\n例如：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n# Returns the total number of entries in the database.\r\nEntry.objects.count()\r\n \r\n# Returns the number of entries whose headline contains \'Lennon\'\r\nEntry.objects.filter(headline__contains=\'Lennon\').count()\r\ncount() 会在后端执行 SELECT COUNT(*) 操作，所以你应该尽量使用 count() 而不是对返回的查询结果使用 len() 。\r\n\r\n根据你所使用的数据库(例如 PostgreSQL 和 MySQL)，count() 可能会返回长整型，而不是普通的 Python 整数。这确实是一个很古怪的举措，没有什么实际意义。\r\n\r\nin_bulk(id_list)\r\n\r\n接收一个主键值列表，然后根据每个主键值所其对应的对象，返回一个主键值与对象的映射字典。\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n>>> Blog.objects.in_bulk([1])\r\n{1: <Blog: Beatles Blog>}\r\n>>> Blog.objects.in_bulk([1, 2])\r\n{1: <Blog: Beatles Blog>, 2: <Blog: Cheddar Talk>}\r\n>>> Blog.objects.in_bulk([])\r\n{}\r\n如果你给 in_bulk() 传递的是一个空列表明，得到就是一个空字典。\r\n\r\niterator()\r\n\r\n运行查询(QuerySet)，然后根据结果返回一个 迭代器(iterator。 做为比较，使用 QuerySet 时，从数据库中读取所有记录后，一次性将所有记录实例化为对应的对象；而 iterator() 则是读取记录后，是分多次对数据实例化，用到哪个对象才实例化哪个对象。相对于一次性返回很多对象的 QuerySet，使用迭代器不仅效率更高，而且更节省内存。\r\n\r\n要注意的是，如果将 iterator() 作用于 QuerySet，那就意味着会再一次运行查询，就是说会运行两次查询。\r\n\r\nlatest(field_name=None)\r\n\r\n根据时间字段 field_name 得到最新的对象。\r\n\r\n下面这个例子根据 pub_date 字段得到数据表中最新的 Entry 对象：\r\n\r\n1\r\nEntry.objects.latest(\'pub_date\')\r\n如果你在 model 中 Meta 定义了 get_latest_by 项, 那么你可以略去 field_name 参数。Django 会将 get_latest_by 做为默认设置。\r\n\r\n和 get(), latest() 一样，如果根据所给条件没有找到匹配的对象，就会抛出 DoesNotExist 异常。\r\n\r\n注意 latest()和earliest() 是纯粹为了易用易读而存在的方法。\r\n\r\nearliest(field_name=None)\r\n\r\n类似于latest()\r\n\r\nfirst()\r\n\r\n1\r\np = Article.objects.order_by(\'title\', \'pub_date\').first()\r\n相当于：\r\n\r\n1\r\n2\r\n3\r\n4\r\ntry:\r\n    p = Article.objects.order_by(\'title\', \'pub_date\')[0]\r\nexcept IndexError:\r\n    p = None\r\nlast()\r\n\r\n类似于first()\r\n\r\naggregate(*args, **kwargs)\r\n\r\n通过对 QuerySet 进行计算，返回一个聚合值的字典。 aggregate() 中每个参数都指定一个包含在字典中的返回值。\r\n\r\n聚合使用关键字参数做为注解的名称。每个参数都有一个为其订做的名称，这个名称取决于聚合函式的函数名和聚合字段的名称。\r\n\r\n例如，你正在处理博文，你想知道博客中一共有多少篇博文：\r\n\r\n1\r\n2\r\n3\r\n>>> from django.db.models import Count\r\n>>> q = Blog.objects.aggregate(Count(\'entry\'))\r\n{\'entry__count\': 16}\r\n通过在 aggregate 指定关键字参数，你可以控制返回的聚合名称：\r\n\r\n1\r\n2\r\n>>> q = Blog.objects.aggregate(number_of_entries=Count(\'entry\'))\r\n{\'number_of_entries\': 16}\r\nexists()\r\n\r\n如果 QuerySet 包含有数据，就返回 True 否则就返回 False。这可能是最快最简单的查询方法了.\r\n\r\nupdate()\r\n\r\n更新\r\n\r\n1\r\n>>> Entry.objects.filter(pub_date__year=2010).update(comments_on=False, headline=\'This is old\')\r\ndelete()\r\n\r\n删除\r\n\r\n1\r\n2\r\n3\r\n4\r\n>>> b = Blog.objects.get(pk=1)\r\n \r\n# Delete all the entries belonging to this Blog.\r\n>>> Entry.objects.filter(blog=b).delete()\r\n字段筛选条件(Field lookups)\r\n字段筛选条件决定了你如何构造 SQL 语句中的 WHERE 从句。它们被指定为 QuerySet 中 filter()，exclude() 和 get() 方法的关键字参数。\r\n\r\nexact\r\n\r\n精确匹配。如果指定的值是 None，就会翻译成 SQL 中的 NULL (详情请查看 isnull )。\r\n\r\n例如：\r\n\r\n1\r\n2\r\nEntry.objects.get(id__exact=14)\r\nEntry.objects.get(id__exact=None)\r\n等价的 SQL：\r\n\r\n1\r\n2\r\nSELECT ... WHERE id = 14;\r\nSELECT ... WHERE id IS NULL;\r\niexact\r\n\r\n忽略大小写的匹配。\r\n\r\n例如：\r\n\r\n1\r\n2\r\nBlog.objects.get(name__iexact=\'beatles blog\')\r\nBlog.objects.get(name__iexact=None)\r\n等价于如下 SQL ：\r\n\r\n1\r\n2\r\nSELECT ... WHERE name ILIKE \'beatles blog\';\r\nSELECT ... WHERE name IS NULL;\r\nSQLite 用户要注意\r\n\r\n在使用 SQLite 作为数据库，并且应用 Unicode (non-ASCII) 字符串时，请先查看 database note 中关于字符串比对那一节内容。SQLite 对 Unicode 字符串，无法做忽略大小写的匹配。\r\n\r\ncontains\r\n\r\n大小写敏感的包含匹配。\r\n\r\n例如：\r\n\r\n1\r\nEntry.objects.get(headline__contains=\'Lennon\')\r\n等价于 SQL ：\r\n\r\n1\r\nSELECT ... WHERE headline LIKE \'%Lennon%\';\r\n要注意，上述语句将匹配大标题 \'Today Lennon honored\' ，但不能匹配 \'today lennon honored\'。\r\n\r\nSQLite 不支持大小写敏感的 LIKE 语句；所以对 SQLite 使用 contains 时就和使用 icontains 一样。\r\n\r\nicontains\r\n\r\n忽略大小写的包含匹配。\r\n\r\n例如：\r\n\r\n1\r\nEntry.objects.get(headline__icontains=\'Lennon\')\r\n等价于 SQL：\r\n\r\n1\r\nSELECT ... WHERE headline ILIKE \'%Lennon%\';\r\nSQLite 用户请注意\r\n\r\n使用 SQLite 数据库并应用 Unicode (non-ASCII) 字符串时，请先查看 database note 文档中关于字符串比对那一节内容。\r\n\r\nin\r\n\r\n是否在一个给定的列表中。\r\n\r\n例如：\r\n\r\n1\r\nEntry.objects.filter(id__in=[1, 3, 4])\r\n等价于 SQL：\r\n\r\n1\r\nSELECT ... WHERE id IN (1, 3, 4);\r\n你也可以把查询(queryset)结果当做动态的列表，从而代替固定的列表：\r\n\r\n1\r\n2\r\ninner_qs = Blog.objects.filter(name__contains=\'Cheddar\')\r\nentries = Entry.objects.filter(blog__in=inner_qs)\r\n做动态列表的 queryset 运行时就会被做为一个子查询：\r\n\r\n1\r\nSELECT ... WHERE blog.id IN (SELECT id FROM ... WHERE NAME LIKE \'%Cheddar%\')\r\n如果你传递了一个 ValuesQuerySet 或 ValuesListQuerySet (它们是调用查询集上 values() 和 values_list() 方法的返回结果) 做为 __in 条件的值，那么你要确认只匹配返回结果中的一个字段。例如，下面的代码能正常的工作(对博客名称进行过滤)：\r\n\r\n1\r\n2\r\ninner_qs = Blog.objects.filter(name__contains=\'Ch\').values(\'name\')\r\nentries = Entry.objects.filter(blog__name__in=inner_qs)\r\n下面的代码却会抛出异常，原因是内部的查询会尝试匹配两个字段值，但只有一个是有用的：\r\n\r\n1\r\n2\r\n3\r\n# Bad code! Will raise a TypeError.\r\ninner_qs = Blog.objects.filter(name__contains=\'Ch\').values(\'name\', \'id\')\r\nentries = Entry.objects.filter(blog__name__in=inner_qs)\r\nwarning\r\n\r\nquery 属性本是一个不公开的内部属性，虽然他在上面的代码中工作得很好，但是它的API很可能会在不同的 Django 版本中经常变动。\r\n\r\n性能考虑\r\n\r\n要谨慎使用嵌套查询，并且要对你所采用的数据库性能有所了解(如果不了解，就去做一下性能测试)。有些数据库，比如著名的MySQL，就不能很好地优化嵌套查询。所以在上面的案例中，先在第一个查询中提取值列表，然后再将其传递给第二个查询，会对性能有较高的提升。说白了，就是用两个高效的查询替换掉一个低效的查询：\r\n\r\n1\r\n2\r\n3\r\nvalues = Blog.objects.filter(\r\n        name__contains=\'Cheddar\').values_list(\'pk\', flat=True)\r\nentries = Entry.objects.filter(blog__in=list(values))\r\ngt\r\n\r\n大于。\r\n\r\ngte\r\n\r\n大于等于。\r\n\r\nlt\r\n\r\n小于。\r\n\r\nlte\r\n\r\n小于等于。\r\n\r\nstartswith\r\n\r\n大小写敏感的以....开头。\r\n\r\nistartswith\r\n\r\n忽略大小写的以....开头。\r\n\r\nendswith\r\n\r\n大小写敏感的以....结尾。\r\n\r\niendswith\r\n\r\n忽略大小写的以....结尾。\r\n\r\nrange\r\n\r\n包含的范围。\r\n\r\n例如：\r\n\r\n1\r\n2\r\n3\r\n4\r\nimport datetime\r\nstart_date = datetime.date(2005, 1, 1)\r\nend_date = datetime.date(2005, 3, 31)\r\nEntry.objects.filter(pub_date__range=(start_date, end_date))\r\n等价于 SQL：\r\n\r\n1\r\nSELECT ... WHERE pub_date BETWEEN \'2005-01-01\' and \'2005-03-31\';\r\n你可以把 range 当成 SQL 中的 BETWEEN 来用，比如日期，数字，甚至是字符。\r\n\r\nyear\r\n\r\n对日期／时间字段精确匹配年分，年分用四位数字表示。\r\n\r\n例如：\r\n\r\n1\r\nEntry.objects.filter(pub_date__year=2005)\r\n等价于 SQL：\r\n\r\n1\r\nSELECT ... WHERE EXTRACT(\'year\' FROM pub_date) = \'2005\';\r\n(不同的数据库引擎中，翻译得到的 SQL 也不尽相同。)\r\n\r\nmonth\r\n\r\n对日期／时间字段精确匹配月分，用整数表示月分，比如 1 表示一月，12 表示十二月。\r\n\r\nday\r\n\r\n对日期／时间字段精确匹配日期。\r\n\r\n要注意的是，这个匹配只会得到所有 pub_date 字段内容是表示 某月的第三天 的记录，如一月三号，六月三号。而十月二十三号就不在此列。\r\n\r\nweek_day\r\n\r\n对日期／时间字段匹配星期几\r\n\r\n例如：\r\n\r\n1\r\nEntry.objects.filter(pub_date__week_day=2)\r\n等价于 SQL：\r\n\r\n1\r\nSELECT ... WHERE EXTRACT(\'dow\' FROM pub_date) = \'2\';\r\n(不同的数据库引擎中，翻译得到的 SQL 也不尽相同。)\r\n\r\n要注意的是，这段代码将得到 pub_date 字段是星期一的所有记录 (西方习惯于将星期一看做一周的第二天)，与它的年月信息无关。星期以星期天做为第一天，以星期六做为最后一天。\r\n\r\nhour\r\n\r\nminute\r\n\r\nsecond\r\n\r\nisnull\r\n\r\n根据 SQL 查询是空 IS NULL 还是非空 IS NOT NULL，返回相应的 True 或 False。\r\n\r\n例如：\r\n\r\n1\r\nEntry.objects.filter(pub_date__isnull=True)\r\n等价于 SQL：\r\n\r\n1\r\nSELECT ... WHERE pub_date IS NULL;\r\nsearch\r\n\r\n利用全文索引做全文搜索。它与 contains 相似，但使用全文索引做搜索会更快一些。\r\n\r\n例如：\r\n\r\n1\r\nEntry.objects.filter(headline__search=\"+Django -jazz Python\")\r\n等价于：\r\n\r\n1\r\nSELECT ... WHERE MATCH(tablename, headline) AGAINST (+Django -jazz Python IN BOOLEAN MODE);\r\n要注意这个方法仅适用于 MySQL ，并且要求设置全文索引。默认情况下 Django 使用 BOOLEAN MODE 模式。详见 Please check MySQL documentation for additional details.\r\n\r\nregex\r\n\r\n大小写敏感的正则表达式匹配。\r\n\r\n它要求数据库支持正则表达式语法，而 SQLite 却没有内建正则表达式支持，因此 SQLite 的这个特性是由一个名为 REGEXP 的 Python 方法实现的，所以要用到 Python 的正则库 re.\r\n\r\n例如：\r\n\r\n1\r\nEntry.objects.get(title__regex=r\'^(An?|The) +\')\r\n等价于 SQL：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\nSELECT ... WHERE title REGEXP BINARY \'^(An?|The) +\'; -- MySQL\r\n \r\nSELECT ... WHERE REGEXP_LIKE(title, \'^(an?|the) +\', \'c\'); -- Oracle\r\n \r\nSELECT ... WHERE title ~ \'^(An?|The) +\'; -- PostgreSQL\r\n \r\nSELECT ... WHERE title REGEXP \'^(An?|The) +\'; -- SQLite\r\n建议使用原生字符串 (例如，用 r\'foo\' 替换 \'foo\') 做为正则表达式。\r\n\r\niregex\r\n\r\n忽略大小写的正则表达式匹配。\r\n\r\n聚合函式(Aggregation Functions)\r\nAvg\r\n\r\n返回所给字段的平均值。\r\n\r\n默认别名：<field>__avg\r\n返回类型： float\r\nCount\r\n\r\n根据所给的关联字段返回被关联 model 的数量。\r\n\r\n默认别名： <field>__count\r\n返回类型： int\r\n它有一个可选参数：\r\n\r\ndistinct\r\n如果 distinct=True，那么只返回不重复的实例数量，相当于 SQL 中的 COUNT(DISTINCT field)。默认值是 False。\r\nMax\r\n\r\n默认别名： <field>__max\r\n返回类型： 与所给字段值相同\r\nMin\r\n\r\n返回所给字段的最小值。','2018-01-28 21:25:09.524010','2018-03-15 13:06:18.879035','p','',102,0,'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1786221164,2797967058&fm=27&gp=0.jpg',0,1,1,'r'),(9,'Django Pagination','Django自带一个分页模块Pagination，具体的参考官方文档，我在这里简单介绍一下具体的例子，模拟一个常用场景，列出部分的代码出来。场景是这样的：我们有一个blog表，其中有若干条记录，我们要对这些记录集进行分页，每页有10条记录，把页码列举出来，页码以a标签的方式链接到本身页码的页面（注意：不是采用Ajax的方式）。\r\n\r\n第一步，取出blog表的全部记录，定义每页记录数，定义当前页 前边页码范围和后边页码范围。\r\nviews.py\r\n```\r\n    from django.core.paginator import Paginator,InvalidPage,EmptyPage,PageNotAnInteger\r\n    blogs=Blog.objects.all()\r\n    page_size=10\r\n    after_range_num = 5\r\n    before_range_num = 6   \r\n    try:\r\n        if page < 1:\r\n            page = 1\r\n    except ValueError:\r\n        page = 1  \r\n    paginator = Paginator(blogs,page_size)\r\n    try:\r\n        blogs = paginator.page(page)\r\n    except(EmptyPage,InvalidPage,PageNotAnInteger):\r\n        blogs = paginator.page(1)\r\n    if page >= after_range_num:\r\n        page_range = paginator.page_range[page-after_range_num:page+before_range_num]\r\n    else:\r\n        page_range = paginator.page_range[0:int(page)+before_range_num]\r\n\r\nindex.html\r\n{% for b in page_objects.object_list%}\r\n<div class=\"node_article\">\r\n<h3><a href=\'{{b.get_absolute_url}}\'>{{b.title}}</a></h3>\r\n<p>{{b.content|safe|escape}}</p>\r\n</div>\r\n{%endfor%}\r\n```\r\npage_objects对象不能看做blog的记录集，page_objects.object_list才是你想要的，然后循环输出记录，把该页的数据集呈现出来。\r\n第三部，页码呈现。\r\n```\r\n{% if page_objects.has_previous %}\r\n<a href=\"?page={{ page_objects.previous_page_number }}\" title=\"Pre\">上一页</a> {% endif %}\r\n{% for p in page_range %}\r\n{% ifequal p page_objects.number %}\r\n<span style=\"font-size:16px;\" title=\"当前页\"><b>{{p}}</b></span>        \r\n{% else %}<a href=\"?page={{p}}\" title=\"第{{p}}页\">{{p}}</a>{% endifequal %}\r\n{% endfor %}     \r\n{% if page_objects.has_next %}\r\n<a href=\"?page={{ page_objects.next_page_number }}\" title=\"Next\">下一页</a>\r\n {% endif %}  \r\n<b>\r\n{%if page_objects.paginator.num_pages%}共 {{ page_objects.paginator.num_pages }} 页{%endif%}\r\n</b>\r\n</p>\r\n```\r\n原文链接：\r\nhttp://blog.csdn.net/clh604/article/details/9284035','2018-03-12 17:32:58.865146','2018-03-12 17:33:55.876576','p','',21,0,'',0,1,1,'r'),(10,'DJANGO ADMIN 一些有用的设置','Django自带的后台管理是Django明显特色之一，可以让我们快速便捷管理数据。后台管理可以在各个app的admin.py文件中进行控制。以下是我最近摸索总结出比较实用的配置。若你有什么比较好的配置，欢迎补充。\r\n \r\n\r\n一、基本设置\r\n1、应用注册\r\n若要把app应用显示在后台管理中，需要在admin.py中注册。这个注册有两种方式，我比较喜欢用装饰器的方式。\r\n\r\n先看看普通注册方法。打开admin.py文件，如下代码：\r\n\r\nfrom django.contrib import admin\r\nfrom blog.models import Blog\r\n  \r\n#Blog模型的管理器\r\nclass BlogAdmin(admin.ModelAdmin):\r\n    list_display=(\'id\', \'caption\', \'author\', \'publish_time\')\r\n     \r\n#在admin中注册绑定\r\nadmin.site.register(Blog, BlogAdmin)\r\n　　上面方法是将管理器和注册语句分开。有时容易忘记写注册语句，或者模型很多，不容易对应。\r\n\r\n还有一种方式是用装饰器，该方法是Django1.7的版本新增的功能：\r\n\r\n\r\nfrom django.contrib import admin\r\nfrom blog.models import Blog\r\n  \r\n#Blog模型的管理器\r\n@admin.register(Blog)\r\nclass BlogAdmin(admin.ModelAdmin):\r\n    list_display=(\'id\', \'caption\', \'author\', \'publish_time\')\r\n　　该方式比较方便明显，推荐用这种方式。\r\n\r\n \r\n\r\n2、admin界面汉化\r\n默认admin后台管理界面是英文的，对英语盲来说用起来不方便。可以在settings.py中设置：\r\n\r\nLANGUAGE_CODE = \'zh-CN\'\r\nTIME_ZONE = \'Asia/Shanghai\'\r\n1.8版本之后的language code设置不同：\r\n\r\nLANGUAGE_CODE = \'zh-hans\'\r\nTIME_ZONE = \'Asia/Shanghai\'\r\n \r\n\r\n二、记录列表界面设置\r\n记录列表是我们打开后台管理进入到某个应用看到的界面，如下所示：\r\n\r\n\r\n\r\n \r\n\r\n我们可以对该界面进行设置，主要包括列表和筛选器。\r\n\r\n \r\n\r\n1、记录列表基本设置\r\n比较实用的记录列表设置有显示字段、每页记录数和排序等。\r\n\r\nfrom django.contrib import admin\r\nfrom blog.models import Blog\r\n  \r\n#Blog模型的管理器\r\n@admin.register(Blog)\r\nclass BlogAdmin(admin.ModelAdmin):\r\n    #listdisplay设置要显示在列表中的字段（id字段是Django模型的默认主键）\r\n    list_display = (\'id\', \'caption\', \'author\', \'publish_time\')\r\n    \r\n    #list_per_page设置每页显示多少条记录，默认是100条\r\n    list_per_page = 50\r\n    \r\n    #ordering设置默认排序字段，负号表示降序排序\r\n    ordering = (\'-publish_time\',)\r\n  \r\n    #list_editable 设置默认可编辑字段\r\n    list_editable = [\'machine_room_id\', \'temperature\']\r\n  \r\n    #fk_fields 设置显示外键字段\r\n     fk_fields = (\'machine_room_id\',)\r\n　　\r\n\r\n此处比较简单，自己尝试一下即可。\r\n\r\n \r\n\r\n另外，默认可以点击每条记录第一个字段的值可以进入编辑界面。 \r\n\r\n\r\n\r\n \r\n\r\n我们可以设置其他字段也可以点击链接进入编辑界面。\r\n\r\nfrom django.contrib import admin\r\nfrom blog.models import Blog\r\n  \r\n#Blog模型的管理器\r\n@admin.register(Blog)\r\nclass BlogAdmin(admin.ModelAdmin):   \r\n    #设置哪些字段可以点击进入编辑界面\r\n    list_display_links = (\'id\', \'caption\')\r\n　　\r\n\r\n2、筛选器\r\n筛选器是Django后台管理重要的功能之一，而且Django为我们提供了一些实用的筛选器。\r\n\r\n主要常用筛选器有下面3个：\r\n\r\nfrom django.contrib import admin\r\nfrom blog.models import Blog\r\n  \r\n#Blog模型的管理器\r\n@admin.register(Blog)\r\nclass BlogAdmin(admin.ModelAdmin):\r\n    list_display = (\'id\', \'caption\', \'author\', \'publish_time\')\r\n     \r\n    #筛选器\r\n    list_filter =(\'trouble\', \'go_time\', \'act_man__user_name\', \'machine_room_id__machine_room_name\') #过滤器\r\n    search_fields =(\'server\', \'net\', \'mark\') #搜索字段\r\n    date_hierarchy = \'go_time\'    # 详细时间分层筛选　\r\n对应效果如下：\r\n\r\n\r\n\r\n 此处注意：\r\n\r\n使用  date_hierarchy  进行详细时间筛选的时候 可能出现报错：Database returned an invalid datetime value. Are time zone definitions for your database and pytz installed?\r\n\r\n处理方法：  \r\n\r\n命令行直接执行此命令：     [root@mysql ~]#    mysql_tzinfo_to_sql /usr/share/zoneinfo | mysql -u root mysql\r\n然后重启数据库即可。\r\n \r\n一般ManyToManyField多对多字段用过滤器；标题等文本字段用搜索框；日期时间用分层筛选。\r\n\r\n过滤器如果是外键需要遵循这样的语法：本表字段__外键表要显示的字段。如：“user__user_name”\r\n\r\n \r\n3、颜色显示\r\n想对某些字段设置颜色，可用下面的设置：\r\n \r\nfrom django.db import models\r\nfrom django.contrib import admin\r\nfrom django.utils.html import format_html\r\n \r\nclass Person(models.Model):\r\n    first_name = models.CharField(max_length=50)\r\n    last_name = models.CharField(max_length=50)\r\n    color_code = models.CharField(max_length=6)\r\n \r\n    def colored_name(self):\r\n        return format_html(\r\n            \'<span style=\"color: #{};\">{} {}</span>\',\r\n            self.color_code,\r\n            self.first_name,\r\n            self.last_name,\r\n        )\r\n \r\nclass PersonAdmin(admin.ModelAdmin):\r\n    list_display = (\'first_name\', \'last_name\', \'colored_name\')\r\n　　\r\n\r\n实际代码（注意看上面代码，是写在models里，而不是admin中的ModelAdmin里）：\r\n\r\n \r\n\r\n效果：\r\n\r\n \r\n\r\n但是，我们看到标题并不是我们想要的，那么如何设置标题呢？\r\n \r\n添加一行代码：colored_status.short_description = u\"状态\"\r\n\r\n \r\n\r\n在函数结束之后添加上面代码即可\r\n\r\n \r\n\r\n 4.调整页面头部显示内容和页面标题\r\n\r\n代码：\r\n\r\nclass MyAdminSite(admin.AdminSite):\r\n    site_header = \'好医生运维资源管理系统\'  # 此处设置页面显示标题\r\n    site_title = \'好医生运维\'  # 此处设置页面头部标题\r\n \r\nadmin_site = MyAdminSite(name=\'management\')\r\n　　需要注意的是：  admin_site = MyAdminSite(name=\'management\') 此处括号内name值必须设置，否则将无法使用admin设置权限，至于设置什么值，经本人测试，没有影响。\r\n\r\n注册的时候使用admin_site.register，而不是默认的admin.site.register。\r\n\r\n效果如下：\r\n\r\n\r\n\r\n 后经网友提示发现也可以这样：\r\n\r\nfrom django.contrib import admin\r\nfrom hys_operation.models import *\r\n \r\n \r\n# class MyAdminSite(admin.AdminSite):\r\n#     site_header = \'好医生运维资源管理系统\'  # 此处设置页面显示标题\r\n#     site_title = \'好医生运维\'\r\n#\r\n# # admin_site = MyAdminSite(name=\'management\')\r\n# admin_site = MyAdminSite(name=\'adsff\')\r\nadmin.site.site_header = \'修改后\'\r\nadmin.site.site_title = \'哈哈\'\r\n　　不继承 admin.AdminSite 了，直接用admin.site 下的 site_header 和 site_title 。\r\n\r\n\r\n\r\n更加简单方便，容易理解。  唯一的区别就是 这种方法 是登录http://ip/admin/\r\n\r\n 站点和用户组在一起\r\n\r\n\r\n\r\n而第一种方法是分开的。\r\n\r\n \r\n5.通过当前登录的用户过滤显示的数据\r\n官方文档的介绍：\r\n\r\n \r\n\r\n \r\n实际代码和效果：\r\n \r\n@admin.register(MachineInfo)\r\nclass MachineInfoAdmin(admin.ModelAdmin):\r\n \r\n    def get_queryset(self, request):\r\n        \"\"\"函数作用：使当前登录的用户只能看到自己负责的服务器\"\"\"\r\n        qs = super(MachineInfoAdmin, self).get_queryset(request)\r\n        if request.user.is_superuser:\r\n            return qs\r\n        return qs.filter(user=UserInfo.objects.filter(user_name=request.user))\r\n \r\n    list_display = (\'machine_ip\', \'application\', \'colored_status\', \'user\', \'machine_model\', \'cache\',\r\n                    \'cpu\', \'hard_disk\', \'machine_os\', \'idc\', \'machine_group\')\r\n\r\n \r\n\r\n \r\n\r\n \r\n三、编辑界面设置\r\n编辑界面是我们编辑数据所看到的页面。我们可以对这些字段进行排列设置等。\r\n\r\n若不任何设置，如下图所示：\r\n\r\n\r\n\r\n \r\n\r\n这个界面比较简陋，需要稍加设置即可。\r\n\r\n \r\n\r\n1、编辑界面设置\r\n首先多ManyToMany多对多字段设置。可以用filter_horizontal或filter_vertical：\r\n\r\n#Many to many 字段\r\nfilter_horizontal=(\'tags\',)\r\n效果如下图：\r\n\r\n\r\n\r\n \r\n\r\n这样对多对多字段操作更方便。\r\n\r\n另外，可以用fields或exclude控制显示或者排除的字段，二选一即可。\r\n\r\n例如，我想只显示标题、作者、分类标签、内容。不想显示是否推荐字段，可以如下两种设置方式：\r\n\r\nfields =  (\'caption\', \'author\', \'tags\', \'content\')\r\n或者\r\n\r\nexclude = (\'recommend\',) #排除该字段\r\n设置之后，你会发现这些字段都是一个字段占一行。若想两个字段放在同一行可以如下设置：\r\n\r\nfields =  ((\'caption\', \'author\'), \'tags\', \'content\')\r\n效果如下：\r\n\r\n\r\n\r\n \r\n\r\n \r\n\r\n2、编辑字段集合\r\n不过，我不怎么用fields和exclude。用得比较多的是fieldsets。该设置可以对字段分块，看起来比较整洁。如下设置：\r\n\r\nfieldsets = (\r\n    (\"base info\", {\'fields\': [\'caption\', \'author\', \'tags\']}),\r\n    (\"Content\", {\'fields\':[\'content\', \'recommend\']})\r\n)','2018-03-13 14:24:57.652266','2018-03-15 13:07:30.107497','p','',16,0,'',0,1,1,'r'),(11,'DJANGO XADMIN的使用 （一）','Django  xadmin的使用\r\nxadmin是django的一个第三方的管理后台实现，它的功能比自带的admin功能更加强大。 \r\nxadmin项目在github上的地址为：https://github.com/sshwsfc/xadmin \r\nxadmin相关文档可以在这里查看：https://xadmin.readthedocs.io/en/latest/index.html\r\n\r\n这里简要总结下自己集成xadmin的方法，我使用的是django1.10和python3.52，xadmin是0.60。\r\n\r\n \r\n\r\n1. 从上面github地址下载 xadmin（网上有说直接pip安装的，但我这里安装失败，可能是python3的缘故吧）。\r\n\r\n\r\n并根据requirements.txt 安装所需要的模块。\r\n\r\n \r\n\r\n2.创建一个新的project，并将上面目录中的xadmin目录拷贝到新的project下。\r\n\r\n\r\n 3.在项目中添加xadmin配置 \r\n1）settings.py文件 \r\nINSTALLED_APPS中添加xadmin的安装，文档网站上是这样写的：\r\n\r\nINSTALLED_APPS = (\r\n    ...\r\n    \'xadmin\',\r\n    \'crispy_forms\',\r\n    \'reversion\',\r\n    ...\r\n)\r\n\r\n\r\n2）urls.py文件 \r\nurls里面要添加xadmin的匹配，示例如下：\r\n\r\nfrom django.conf.urls import patterns, include, url\r\nfrom xadmin.plugins import xversion\r\nimport xadmin\r\n\r\n#version模块自动注册需要版本控制的 Model\r\nxversion.register_models()\r\n\r\nxadmin.autodiscover()\r\n\r\nurlpatterns = [\r\n    ...\r\n    url(r\'xadmin/\', include(xadmin.site.urls)),\r\n]\r\n\r\n4.创建一个app，写models，将app注册。\r\npython manage.py startapp hys_datamanagement\r\n\r\n\r\n\r\nmodels：\r\n\r\nfrom django.db import models\r\n \r\n \r\nclass UserInfo(models.Model):\r\n    \"\"\"用户表\"\"\"\r\n    user_name = models.CharField(max_length=20, unique=True, verbose_name=u\"负责人\")         # 负责人\r\n    user_email = models.EmailField(null=True, blank=True, verbose_name=u\"邮箱\")     # 邮箱\r\n    user_mobile = models.BigIntegerField(verbose_name=u\"电话\")                 # 电话\r\n \r\n    class Meta:\r\n        db_table = \'user_info\'\r\n        verbose_name = \'用户表\'\r\n        verbose_name_plural = \"用户表\"\r\n \r\n    def __str__(self):\r\n        return self.user_name\r\n　　　　\r\n\r\n然后再注册app：\r\n\r\n\r\n\r\n5.修改数据库连接信息，配置 Django 以便与 Oracle 数据库交互。\r\n　　由于本次示例使用oracle数据库现有数据，所以配置连接oracle\r\n\r\n      首先，您必须安装对应版本的cx_Oracle。 下载地址：https://pypi.python.org/pypi/cx_Oracle \r\n打开 settings.py 文件，并根据您的数据库编辑与数据库相关的设置。例如，您可能按如下方式编辑它们：\r\n\r\nDATABASES = {\r\n    \'default\': {\r\n        \'ENGINE\': \'django.db.backends.oracle\',\r\n        \'NAME\': \'orcl\',\r\n        \'USER\': \'hys_datamanagement\',\r\n        \'PASSWORD\': \'hys_datamanagement\',\r\n        \'HOST\': \'192.168.168.224\',\r\n        \'PORT\': \'1521\',\r\n    }\r\n}\r\n　　注：创建数据库用户的语句：\r\n\r\ncreate user hys_datamanagement identified by hys_datamanagement;\r\ngrant connect,resource to hys_datamanagement;\r\n\r\n \r\n\r\n然后创建数据库表：\r\n\r\npython manage.py makemigrations\r\n\r\npython manage.py migrate\r\n\r\n 效果：\r\n\r\n\r\n\r\n \r\n\r\n6.配置adminx.py文件 \r\ndjango自带的admin模块使用的是admin.py文件，xadmin模块的文件名则叫adminx.py。\r\n\r\nadmin模块在配置时使用的参数是admin.ModelAdmin，xadmin则使用object即可。然后替换admin.site.register为xadmin.site.register。如下：\r\n\r\n\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n# from django.contrib import admin\r\nfrom .models import UserInfo\r\nimport xadmin\r\n \r\n \r\nclass UserInfoAdmin(object):\r\n    list_display = (\'user_name\', \'user_email\', \'user_mobile\')\r\n \r\nxadmin.site.register(UserInfo, UserInfoAdmin)\r\n　　\r\n\r\n然后就可以启动服务，看看效果了：\r\n\r\n访问  http://127.0.0.1:8000/xadmin/\r\n\r\n\r\n\r\n通过命令 python manage.py createsuperuser 创建超级用户。\r\n\r\n\r\n\r\n登录后：\r\n\r\n\r\n\r\n至此，基本配置就完成了。','2018-03-13 14:26:14.409335','2018-03-13 14:26:14.409366','p','',11,0,'',0,1,1,'r'),(12,'DJANGO XADMIN的使用 （二）','上一篇中我们基本完成了xadmin的配置，但是要进行正式使用还需要更多细致的配置。\r\n\r\n \r\n\r\n1.页面显示中文\r\nsettings.py中配置（这个和django自带的admin配置一样）\r\n\r\n# LANGUAGE_CODE = \'en-us\'\r\nLANGUAGE_CODE = \'zh-hans\'\r\n \r\n# TIME_ZONE = \'UTC\'\r\nTIME_ZONE = \'Asia/Shanghai\'\r\n可见登录页面和首页都变成中文了：\r\n\r\n\r\n\r\n \r\n\r\n 2.xadmin的site-title和site-footer，菜单折叠\r\nsite-title和site-footer都是设置在base_site.html模板页面中的，可以从xadmin的安装目录下的xadmin\\templates\\xadmin目录中找到：\r\n\r\n\r\n\r\n\r\n\r\n从图片中可以看出来，site_title和site_footer都是可以通过程序设置的变量，那么想要设置这两个变量要怎么做呢？只要在adminx.py文件中添加GlobalSetting类，具体代码如下：\r\n\r\nfrom xadmin import views\r\n \r\n \r\nclass GlobalSetting(object):\r\n    # 设置base_site.html的Title\r\n    site_title = \'我的脑袋\'\r\n    # 设置base_site.html的Footer\r\n    site_footer  = \'我的脚丫\'\r\nxadmin.site.register(views.CommAdminView, GlobalSetting)\r\n　　效果：\r\n\r\n\r\n\r\n设置菜单折叠，在上面代码下添加：   menu_style = \"accordion\"\r\n\r\n折叠菜单如下：\r\n\r\n\r\n\r\n \r\n\r\n 3.设置models的全局图标\r\n和上面修改title和footer一样，在类GlobalSetting 中添加：\r\n\r\n1\r\n2\r\n3\r\nglobal_models_icon = {\r\n    V_UserInfo: \"glyphicon glyphicon-user\", UserDistrict: \"fa fa-cloud\"\r\n}  # 设置models的全局图标\r\n　　\r\n\r\n \r\n\r\n这样我们可以看到图标的model图标的变化\r\n\r\n\r\n\r\n至于图标的对应代码可以去  \r\n\r\nhttp://v3.bootcss.com/components/\r\n\r\nhttp://www.yeahzan.com/fa/facss.html \r\n\r\n上查找。\r\n\r\n官网是这样介绍的：\r\n\r\n\r\n\r\n \r\n\r\n4.设置app标题。\r\n\r\n\r\n这里还显示的是我们app的名字，怎么修改呢？\r\n\r\n涉及2个地方：\r\n\r\n1> apps.py里添加verbose_name\r\n\r\n\r\n\r\n2>__init__.py添加默认配置。\r\n\r\n\r\n\r\n之后我们就可以看到修改后的页面了：\r\n\r\n\r\n\r\n \r\n\r\n5.显示数据详情\r\n设置 OptionClass 的 show_detail_fields .  \r\n\r\n\r\n\r\n效果：\r\n\r\n\r\n\r\n6.列表定时刷新\r\n 设置 OptionClass 的 refresh_times 属性即可. refresh_times 属性是存有刷新时间的数组. xadmin 默认不开启该插件.\r\n\r\n\r\n\r\n效果如下：\r\n\r\n\r\n\r\n7.书签\r\n数据列表页面特定的数据过滤，排序等结果，添加的书签还可以在首页仪表盘中作为小组件添加。\r\n\r\n在Model  OptionClass中设定如下属性：\r\n\r\n \r\n\r\nshow_bookmarks 属性:\r\n\r\n设置是否开启书签功能, 默认为 True\r\n\r\nlist_bookmarks 属性:\r\n\r\n设置默认的书签. 用户可以在列表页面添加自己的书签, 你也可以实现设定好一些书签, 使用实例如下:\r\n\r\n 使用实例如下:\r\n\r\nlist_bookmarks = [{\r\n    \"title\": \"存在邮箱\",\r\n    \"query\": {\"user_email__contains\": \'@\'},\r\n    \"order\": (\"-user_name\",),\r\n    \"cols\": (\'user_name\', \'user_email\', \'user_mobile\'),\r\n    }]\r\n　　\r\n\r\n效果：\r\n\r\n\r\n\r\n \r\n\r\n8.图表\r\n在数据列表页面，根据列表数据生成图表，可以指定多个数据列，生成多个图表。\r\n\r\n 在Model OptionClass 中设定data_charts属性，该属性为dict类型，key是图表的标示名称，value是图表的具体设置属性，示例:\r\n\r\ndata_charts = {\r\n    \"user_count\": {\'title\': u\"User Register Raise\", \"x-field\": \"year\", \"y-field\": (\"cn\",),\r\n                   \"order\": (\'year\',)},\r\n    # \"avg_count\": {\'title\': u\"Avg Report\", \"x-field\": \"date\", \"y-field\": (\'avg_count\',), \"order\": (\'date\',)}\r\n    }\r\n　　\r\n\r\n图表的主要属性为:\r\n\r\ntitle : 图表的显示名称\r\n\r\nx-field : 图表的 X 轴数据列, 一般是日期, 时间等\r\n\r\ny-field : 图表的 Y 轴数据列, 该项是一个 list, 可以同时设定多个列, 这样多个列的数据会在同一个图表中显示\r\n\r\norder : 排序信息, 如果不写则使用数据列表的排序\r\n\r\n效果：\r\n\r\n\r\n\r\n9.数据导出\r\n如果想要导出Excel数据，需要安装xlwt。\r\n\r\n默认情况下，xadmin会提供Excel，CSV,XML，json四种格式的数据导出，可以通过设置OptionClass的list_export属性来指定使用哪些导出格式（四种格式分别用xls，csv，xml，json表示）或是将list_export设置为None来禁用数据导出功能。\r\n\r\n\r\n\r\n \r\n\r\n10.过滤\r\n在 Model OptionClass 中设置以下属性:\r\n\r\nlist_filter 属性:\r\n\r\n该属性指定可以过滤的列的名字, 系统会自动生成搜索器\r\n\r\nsearch_fields 属性:\r\n\r\n属性指定可以通过搜索框搜索的数据列的名字, 搜索框搜索使用的是模糊查找的方式, 一般用来搜素名字等字符串字段\r\n\r\nfree_query_filter 属性:\r\n\r\n默认为 True , 指定是否可以自由搜索. 如果开启自由搜索, 用户可以通过 url 参数来进行特定的搜索, 例如:\r\n\r\nhttp://xxx.com/xadmin/auth/user/?name__contains=tony\r\n \r\n11. 设置只读字段\r\n 在使用xadmin的时候，ModelAdmin默认只有对于model的增删改查，但是总是有些字段是不希望用户来编辑的。而 readonly_fields 设置之后不管是admin还是其他用户都会变成只读，而我们通常只是想限制普通用户。 这时我们就可以通过重写 get_readonly_fields 方法来实现对特定用户的只读显示。\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\nclass UserInfoAdmin():\r\n \r\n    def get_readonly_fields(self):\r\n        \"\"\"  重新定义此函数，限制普通用户所能修改的字段  \"\"\"\r\n        if self.user.is_superuser:\r\n            self.readonly_fields = []\r\n        return self.readonly_fields\r\n     \r\n    readonly_fields = (\'user_email\',)\r\n　　效果：\r\n\r\n普通用户：\r\n\r\n\r\n\r\nadmin：\r\n\r\n\r\n\r\n \r\n\r\n \r\n\r\n参考： http://xadmin.readthedocs.io/en/docs-chinese/plugins.html \r\n\r\n         http://blog.csdn.net/lyysr/article/details/48735053\r\n\r\n         http://www.cnblogs.com/shhnwangjian/p/6372503.html','2018-03-13 14:28:04.868545','2018-03-13 14:28:04.868576','p','',37,0,'',0,1,1,'r'),(13,'Python爬取内涵段子搞笑视频','本人资深段友，“滴！滴滴！”，前段时间老婆总让我说笑话给她听，本人不善言辞，正常说话都困难，更别说讲笑话了，更更别说讲有内涵有质量的笑话了，但是本屌丝经常看内涵段子，说服不了老婆大人下载这个APP，所以本屌只有曲线救国，想到了可以用Python爬取内涵段子的优质笑话，然后利用微信公众号展示出来。具体思路就是在微信里面输入‘笑话’，然后会随机推送10条左右的视频笑话。微信公众号的实现以后有机会再贴出来，今天主要想把最核心的python如何爬取内涵视频并保存到数据库里分享给大家。说干就干\r\n   \r\n需求：爬取内涵段子视频并保存到数据库(找出视频url并存到数据库)\r\n   \r\n工具： python\r\n   \r\n数据库： MySQL\r\n   \r\n准备工作：\r\n   \r\n1.分析内涵段子视频页面，找出视频url   \r\n\r\n百度搜索‘内涵段子’，然后进入内涵段子官网，也就是内涵社区,图片我就不贴了，比较麻烦，然后大家可以看到官网主页里只有“段子”，“图片”，“网络表演”三个子类，并没有我们要找的视频，怎么办？据本屌经验， 通常文档是xxx.com/text/,图片是xxx.com/pic/(为什么是pic而不是picture？因为程序员通常比较懒，能少打一个字母不会多打)，以此类推视频应该是xxx.com/video/,试了一下[http://www.neihanshequ.com/video/](http://www.neihanshequ.com/video/\"内涵视频\")，果然进入了内涵段子视频专栏，O(∩_∩)O哈哈哈~。   \r\n\r\n然而问题又来了，如果有爬虫经验的应该知道，比如爬取今日头条这样的内容型网站，我所知道的内容通常有两种显示方式：一种是分页的形式，本博客的文章下方的分页就是这种形式，一种是流加载，流加载可以先加载部分，然后页面底部加一个“Load More”等，当用户点击触发的时候继续加载，以此类推，本博客的“[关于爱情](http://39.106.189.163/love/)”专栏就是用这种方式实现的，当然还有一种实现方式是当滑动鼠标到底部的时候触发继续加载，换汤不换药，很多图片网站都是通过鼠标滑动触发的，给用户的感觉就是源源不断的数据。好了，说了这么多，内涵段子视频专栏的加载方式大家可以看到是流加载的鼠标点击触发的方式，那么问题又来了，数据从哪里来呢？数据库？还是其他什么地方？   \r\n\r\n我们可以用浏览器分析工具看一下，按F12后选择Network，这样你的每一步操作加载的内容都可以看到，我们可以尝试点击“加载更多”，看看有哪些内容被加载了，多点几次，找找规律。   \r\n\r\n 好了，我们可以看到有一个is_json=1&app_name=neihanshequ_web&max_time=这样的东西，每次你点击“加载更多”的时候，这个东西都会出现一次，大家如果做过Web方面的开发应该对Restful不陌生，这个就是传说中的WEB API，你用浏览器打开这个url可以发现这就是典型的Restful风格的Web API，这就是内涵段子的数据来源，JSON格式的Restful，因为本屌之前做过一个项目，用Django REST Framework开发过Web API，所以对这个非常熟悉，如果你不熟悉也没关系，只要知道这是数据来源，是JSON格式，如果你不知道JSON，那么你就把它当成是字典，如果你不知道字典，你就把它当成键、值（key:value）,如果你不知道.。。。，那么关掉此博客，出门左转是护城河。   \r\n\r\n闲话少说，找到了内涵段子的数据来源，那么我们就分析一下它的Web API，http://neihanshequ.com/video/?is_json=1&app_name=neihanshequ_web&max_time=xxx, 前面部分http://neihanshequ.com/video/没什么好说，就是站点Host，后面的is_json=1&app_name=neihanshequ_web&max_time=xxx，is_json=1代表是JSON格式的数据，可能还有其他格式的，app_name=neihanshequ_web代表是内涵社区Web版，也可能有其他版本，这些我们都不需要改变，最后一个max_time=，如果我没有猜错的话，内涵段子的用户上传的内容，如段子、图片、视频等都是以时间戳的形式，被Restful序列化，事实上我们如果任意改变max_time后的数字确实可以得到不同的JSON数据，那么好吧，就从这里出发，数据有了，下一步就是分析JSON数据里面的.mp4后缀的应该就是内涵视频的url，只要取出这些url存到数据库就大功告成了，说到这儿，我觉得下一步有必要跟大家分享一下Restful这个知识点（要分享的东西还挺多呀( ˇˍˇ )）。\r\n直接贴代码吧：\r\n\r\n    #coding=utf-8\r\n    import os,sys,time,datetime\r\n    import re\r\n    import requests,json\r\n    import MySQLdb\r\n       def get_video():\r\n            current_time = time.time()\r\n            #n = 0\r\n        result_list =[]\r\n        for i in range(int(current_time)-100000,int(current_time),10000):\r\n            url = \'http://neihanshequ.com/video/?is_json=1&app_name=neihanshequ_web&max_time=%s\'%i\r\n            data = requests.get(url).text.encode(\"utf-8\")\r\n            hjson = json.loads(data)\r\n        #print hjson[\'data\'][\'data\'][-1][\'group\']\r\n        for temp in hjson[\'data\'][\'data\']:\r\n            result_dist = {}\r\n            favorite_count = temp[\'group\'][\'favorite_count\']\r\n            if favorite_count > 10000:\r\n                result_dist[\'favorite_count\'] = favorite_count\r\n                result_dist[\'comment_count\'] = temp[\'group\'][\'comment_count\']\r\n                result_dist[\'user_favorite\'] = temp[\'group\'][\'comment_count\']\r\n                result_dist[\'mp4_url\'] = temp[\'group\'][\'mp4_url\']\r\n                result_dist[\'content\'] = temp[\'group\'][\'content\']\r\n                if result_dist not in result_list:\r\n                    result_list.append(result_dist)\r\n                #print \'comment_count\',temp[\'group\'][\'comment_count\']\r\n                #print \'user_favorite\',temp[\'group\'][\'user_favorite\']\r\n                #print \'content\', temp[\'group\'][\'content\']\r\n                #print temp[\'group\'][\'mp4_url\']\r\n                #n+=1\r\n                #print n\r\n        return result_list\r\n    def connectMySQL():\r\n      conn=MySQLdb.connet(host=\'localhost\',user=\'root\',password=\'sq416221@\',db=\'test\',charset=\'utf8\')\r\n        return conn\r\n    def save2mysql(result_list):\r\n    conn = connectMySQL()\r\n    cur = conn.cursor()\r\n    for i,video in enumerate(result_list):\r\n        print \'正在插入第%d条内涵视频\'%(i+1)\r\n        sql = \'select 1 from neihan_video where video_url=\"%s\" limit 1;\'%(video[\'mp4_url\'])\r\n        isExit = cur.execute(sql)\r\n        if isExit == 1:\r\n            print \'数据库中已经存在此内涵视频，放弃插入\'\r\n        else:\r\n            sql = \'insert into neihan_video(content,favorite_count,video_url) values(\"%s\",\"%s\",\"%s\")\'%(video[\'content\'],video[\'favorite_count\'],video[\'mp4_url\'])\r\n            cur.execute(sql)\r\n    print \'正在提交操作...\'\r\n    conn.commit()\r\n    cur.close()\r\n    conn.close()\r\n\r\n    if __name__ == \'__main__\':\r\n    try:\r\n        result_list = get_video()\r\n        save2mysql(result_list)\r\n    except Exception,e:\r\n        print e','2018-03-20 14:07:15.706570','2018-03-21 10:26:25.864193','p','',82,100,'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1521536075376&di=6c810dbf188a05200c1eb9568d0eeecf&imgtype=0&src=http%3A%2F%2Fimg.mukewang.com%2F57466ffc00015e2f06000338-590-330.jpg',1,2,5,'o'),(14,'区块链基本知识','解读    \r\n\r\n1.区块链是什么？   \r\n\r\n（1）基本概念\r\n\r\n什么是区块链技术？为了感性认识这个问题，我们可以使用谷歌地球的例子做类比，ajax不是什么新技术，但组合在一起就成就了产品谷歌地球，与之类似，区块链也不是什么新技术，但与加密解密技术、P2P网络等组合在一起，就像ajax一样诞生了比特币。技术人员，特别是Web开发工程师，学习了解ajax技术最早是被谷歌地球酷炫的效果所吸引。而现在，历史再一次重演，很多人被比特币的疯狂发展所吸引，进而开始研究其背后的技术区块链。\r\n\r\n使用学术点的文字来描述，区块链其实就是一种专用的数据存储技术，它使用特有的数据结构和数据形式来存储大量交易信息，每条记录从后向前有序链接起来，具备公开透明、无法篡改、方便追溯的特点。这里的交易不仅仅是一次购买支付行为，包括各类有价值、有所属的数字资产，所以更简单的说法是，区块链是去中心化的公共账本。区块链可以存储成文件形式，不过多数产品存储在一个数据库中，比如比特币使用Google的LevelDB数据库存储。\r\n\r\n与加密货币相比，区块链这个名字抛开了代币的概念，更加形象化、技术化、去政治化，更适合作为一门技术去研究、去推广。\r\n\r\n（2）从数据库设计角度理解区块链\r\n\r\n用数据库的概念理解，区块链就是一张“自引用”的数据库表。每条记录代表一个区块，这条记录（区块）记录着它前面（时间上）一条记录的信息，可以直接查询到前一条记录，因此从任何一条记录开始都可以往前顺序追溯，直到第一条记录。普通自引用表结构，通常使用ID作为关联外键，加密货币使用的是经过加密处理的信息字段，具有签名认证作用，可实现自我验证，防止被篡改。\r\n\r\n与区块链直接关联的另一张重要的表，就是交易表。加密货币包含大量的交易，我们之前分析过，交易可以是加密货币，也可以是债权、股权或版权等各类数字资产，这些交易保存在一张独立表里，并与区块链形成多对一的关联方式。如此以来，只要追溯到区块，就很容易查询到该区块包含的交易记录。这样，一个公开透明、无法篡改、方便追溯的账本就形成了。\r\n\r\n上面是从数据库查询（读数据）的角度考虑的，如果从写入的角度思考，就更有意思了。写入是要根据需求不同进行不同的编码，我们前面的章节说过，加密货币的各种功能都可以通过扩展交易类型进行编码，如果把一些现实中的合同规则进行编码，要求系统在某个条件下自动执行（写入或更新）某交易，自然也是件简单轻松的事情，这就是“智能合约”的简单理解。\r\n\r\n我们在第一部分提到过“智能合约”的概念，在这里再次提及，作为程序员能够更加直观的去理解编码上的可行性。“智能合约”也是目前加密货币社区讨论火热的概念，可以发挥你想象的翅膀，从加密货币扩展到现实世界的各种场景，比如：自动贩卖机、销售终端、大公司间的电子数据交换、银行间用于转移与清算的支付网络，以及音乐、电影和电子书等数字版权交易等。\r\n\r\n（3）形象化理解区块链\r\n\r\n人们通常把具有先后顺序的数据结构，使用栈来表示，比特币白皮书把这种结构进一步形象化，第一个区块作为栈底，然后其他区块按照时间顺序依次堆叠在上面，这样一来，区块与首区块之间的距离就表示“高度”，“顶端”就表示最新添加的区块。每个区块包含大量交易，就是包含在对应栈里的数据。我们可以把这样的结构想象成一个大大的橱柜，区块就是其中一个抽屉，每个抽屉里是满满的交易，就象下面这样：\r\n![stack-drawers.png](http://img.blog.csdn.net/20160801114147294)\r\n\r\n（4）区块链分叉\r\n\r\n物理分叉。每一个区块都与它的前一区块（父区块）关联，而对它后面的区块（子区块）无限制，也就是说最顶端的区块，肯定知道它的父区块（已经写入区块链），但不知道子区块（或许还没有产生，也可能在传输的过程中）。我们知道，从物理层面，数据库、硬盘、网络的IO操作是最耗费时间的，在某一个时刻，多个最新区块同时找到父区块是很常见的现象，这就必然导致区块链分叉（从主链向多个方向发展）。这是在同一个软件版本（及其兼容版本）的情况下发生的，没有人为干预，不妨叫做物理分叉。\r\n\r\n显然，物理分叉取决于物理环境，这与什么样的共识机制没有直接关系，不论是采取工作量证明机制（PoW)的比特币、还是采取股权证明机制（PoS）的点点币，亦或是这里采取授权股权证明机制（DPoS）的亿书币，都是如此。为了保持区块链的单一链条，解决分叉的最简单方式就是放任每个分叉继续增长，通常在下一刻就会出现差别，这时候软件选择最长的那个链条作为主链即可。在具体的设计开发过程中，这也是一个逻辑相对复杂的难点。\r\n\r\n人为分叉。那么，如果存在人的干预，会怎么样呢？我们知道，世界上没有绝对完美的东西，人类开发设计的软件也不例外，漏洞是常有的，看看微软的windows系统时不时跳出来的漏洞修复提醒，就知道这类事情多么常见。而且，人类的需求始终在变化，软件要不断推出新功能来应对。所以，软件出现漏洞，或者添加新的功能，这类情况是再正常不过的事情。这时候，旧版本的软件对新版本软件产生的区块可能出现兼容性问题，甚至需要人为改变区块链的走向，这就导致新旧版本之间出现分叉，不妨叫做人为分叉。\r\n\r\n很显然，人为分叉也是无法避免的事情。你可能认为很简单，有漏洞就修复吧，有新功能加上就得了，有什么好解释的。事实上，加密货币核心是交易，是价值转移的手段，规则的改变直接关系到所有持币人的利益。我们在第一部分说过，人是趋利的，要追求利益最大化，新功能能否保护用户的利益，还是代表了少部分利益集团的意志，应该如何约束和决策，这已经不单单是一个技术问题，更多的是社区政治问题，需要社区共同参与。历史证明，承载了较大资金盘的加密货币，在某一次分叉过程中，个别用户或矿工没有及时更新软件，就造成了直接经济损失。所以，每一个持币用户都非常关心任何一次分叉行为，都有可能站出来表达自己的意愿，甚至选择留在旧链上。\r\n\r\n硬分叉和软分叉。它们都属于人为分叉，孰优孰劣也是当前社区分歧比较严重的问题。最初，社区区分这两个概念的简单方法就是，“硬分叉”是与旧版本的兼容度不高，但是获得了社区共识的规则明确的分叉行为，“软分叉”恰恰相反。发展到今天，只要是明确的“分叉”行为，大家都会寻求社区共识，所以二者的区别主要集中在软件兼容问题上了。这里的社区共识，是指包括软件开发者、矿工和使用者在内的整个软件社区，采取投票等方式，获得最大程度的一致性意见，通常是90%以上的社区成员同意就认为是达成了社区共识。比如最近以太坊为了应对The Dao遭受黑客攻击而实施的紧急硬分叉，就获得了社区87%的同意（接近90%，这里不讨论这次分叉行为的好坏）。\r\n\r\n从技术角度讲，这里所谓的“硬”，主要体现在与旧版本的不兼容（或少量兼容）上，属于抛弃旧版本的行为，如果用户不升级软件，就永远留在旧链上，感觉上更加强硬得多。“软分叉”，最大程度的保持了对以前版本的兼容性，做得好的话，多个版本可以同时运行，类似于正常的版本迭代升级，用户可以自由选择是否升级。有人说“硬分叉”是很糟糕的事情，另一些人认为“软分叉”风险更大。事实证明，只要准备充分，操作得当，无论是“硬分叉”，还是“软分叉”，都不可怕，只不过“软分叉”在编码中需要考虑的情况更加复杂，对用户的影响较为隐蔽。\r\n\r\n我个人不喜欢谈政治，但是作为交易媒介的新兴产物——加密货币，天生就是政治的附属品。这些货币的持续发展，往往是不同利益团体（包括开发者、矿工和用户）之间不断博弈的结果。最初是开发者主导，某个时期矿工的力量更加强大，后期用户的力量就不容忽视。也正是这些力量之间的制衡，才让加密货币相对持续稳健的发展，当这三种力量达到均衡的时候，就是这个加密货币相对成熟的时候。最近，以太坊硬分叉处理Dao遭受的黑客攻击事件，搅动了整个加密货币社区，不同利益者发出不同的声音，这是好事，充分说明加密货币仍处在初级阶段，还有很长的路要走。\r\n\r\n2.区块链的特点\r\n我们可以按照堆栈的方式理解数据结构，并采用自引用的关联方式设计数据库模型，但是做到这些，我个人认为并不代表就是区块链了，它还必须使用加解密技术，被置于去中心化的网络，由P2P网络节点共同维护，才能称得上区块链。当然，也有人持不同观点，他们认为一个中心化的应用，如果使用类似的数据结构，会更加安全（比不使用该结构的中心化系统），同时可以避免分叉，性能或许更高（比去中心化的系统），但事实上没有了P2P网络的支撑，这点改进算不上什么。我们之前分析过，P2P网络本身就是一条非常好的安全屏障，单点被攻击或被破解，对整个网络系统没有太大伤害，而任何中心化的系统仅仅相当于单节点，安全性大大降低。所以，为了那些许的性能改进，却要牺牲更好的安全性，有点得不偿失。\r\n\r\n汇总以上信息，区块链应该具备这样几个特点：\r\n\r\n分布存储：区块链处于P2P网络之中，无论什么公链、私链，还是联盟链，都要采取分布式存储，使用一种机制保证区块链的同步和统一;\r\n公开透明：每个节点都有一个区块链副本，区块链本身没有加密，数据可以任意检索和查询，甚至可以修改（改了也没用）;\r\n无法篡改：这是加密技术的巧妙应用，每一区块都会记录前一区块的信息，并实现验证，确保无法篡改。这里的无法篡改不是不能改，而是局部修改的数据，无法通过验证，要想通过验证，必须修改整个区块链，这在理论上可行，操作上不可行;\r\n方便追溯：区块链是公开的，从任一区块都可以向前追溯，直到第一个区块，并通过区块查到与之关联的全部交易；\r\n存在分叉：这是由P2P网络等物理环境，以及软件开发实践过程决定的，人们无法根本性杜绝。\r\n也正是因为这样的特点，区块链的概念才逐渐火爆起来。实践证明，区块链技术能实现一切中心化应用的场景，可以解决（或更好的解决）很多中心化应用无法解决的问题，比如分布式财务管理、分布式存储、知识产权保护、电子商务，乃至物联网，特别是对于金融业而言，资金清算、审计等等，成本会大幅度降低。亿书，就是利用它公开透明、可追溯的特点，与数字出版结合起来，实现自媒体和版权保护，彻底解决当前数字出版版权保护不力的顽疾。\r\n\r\n3.区块链开发应该解决的问题\r\n明白区块链是什么和基本原理之后，就可以着手设计其基本功能了。从需求的角度说，设计中需要做到如下几点：\r\n\r\n（1）加载区块链。确保本地区块链合法，未被篡改。\r\n\r\n保存创世区块\r\n加载本地区块\r\n验证本地区块\r\n（2）处理新区块。加载后，该节点就可以处理网络中的交易了。\r\n\r\n创建新区块；\r\n收集整理交易，写入（关联）区块；\r\n把新产生的区块写入区块链；\r\n处理区块链分叉。\r\n（3）同步区块链。确保本地区块链与网络中完整的区块链同步。   \r\n转自：http://blog.csdn.net/imfly/article/details/52084392','2018-03-20 17:45:26.504435','2018-03-20 17:49:36.867430','p','',23,0,'http://img.blog.csdn.net/20160801114051950',0,2,8,'r'),(15,'Django模板语言','http://blog.csdn.net/pipisorry/article/details/45727309\r\n\r\nDjango模板语言 The Django template language\r\n模板中常用的语法规则\r\n{最新版本的Django语法可能有改变，不支持的操作可能支持了。[HTML教程 - 基本元素/标签及属性]}\r\n\r\nDjango变量Variables\r\n\r\nA variable outputs a value from the context, which is a dict-like objectmapping keys to values.\r\n\r\nVariables are surrounded by {{ and}} like this:\r\n\r\nMy first name is {{ first_name }}. My last name is {{ last_name }}.\r\nWith a context of {\'first_name\':\'John\',\'last_name\': \'Doe\'}\r\nDjango 模板标签\r\nif/else 标签\r\n1. 基本语法格式如下：\r\n{% if condition %}\r\n     ... display\r\n{% endif %}\r\n或者：\r\n\r\n{% if condition1 %}\r\n   ... display 1\r\n{% elif condiiton2 %}\r\n   ... display 2\r\n{% else %}\r\n   ... display 3\r\n{% endif %}\r\n根据条件判断是否输出。if/else 支持嵌套。\r\n\r\nNote:模板标签中的变量是不用{{}}包含的。\r\n\r\n2. {% if %} 标签接受 and ， or 或者 not 关键字来对多个变量做判断 ，或者对变量取反（ not )，例如：\r\n\r\n{% if athlete_list and coach_list %}\r\n     athletes 和 coaches 变量都是可用的。\r\n{% endif %}\r\nNote:\r\n\r\n1. {% if %} 标签不允许在同一个标签中同时使用 and 和 or ，因为逻辑上可能模糊的，这样的代码是不合法的：\r\n\r\n{% if athlete_list and coach_list or cheerleader_list %}\r\n2. 系统不支持用圆括号来组合比较操作。 如果你确实需要用到圆括号来组合表达你的逻辑式，考虑将它移到模板之外处理，然后以模板变量的形式传入结果吧。 或者，仅仅用嵌套的{%if%}标签替换\r\nfor 标签\r\n\r\n1. {% for %} 允许我们在一个序列上迭代。与Python的 for 语句的情形类似，循环语法是 for X in Y ，Y是要迭代的序列而X是在每一个特定的循环中使用的变量名称。\r\n\r\n每一次循环中，模板系统会渲染在 {% for %} 和 {% endfor %} 之间的所有内容。\r\n\r\n例如，给定一个运动员列表 athlete_list 变量，我们可以使用下面的代码来显示这个列表：\r\n<ul>\r\n{% for athlete in athlete_list %}\r\n    <li>{{ athlete.name }}</li>\r\n{% endfor %}\r\n</ul>\r\n2. 给标签增加一个 reversed 使得该列表被反向迭代：\r\n\r\n{% for athlete in athlete_list reversed %}\r\n3. 可以嵌套使用 {% for %} 标签。\r\n\r\n在执行循环之前先检测列表的大小是一个通常的做法，当列表为空时输出一些特别的提示。`` for`` 标签支持一个可选的`` {% empty %}`` 分句，通过它我们可以定义当列表为空时的输出内容 下面的例子与用if-else实现等价：\r\n\r\n{% for athlete in athlete_list %}\r\n    <p>{{ athlete.name }}</p>\r\n{% empty %}\r\n    <p>There are no athletes. Only computer programmers.</p>\r\n{% endfor %}\r\n4. Django不支持退出循环操作。 如果我们想退出循环，可以改变正在迭代的变量，让其仅仅包含需要迭代的项目。 同理，Django也不支持continue语句，我们无法让当前迭代操作跳回到循环头部。\r\n\r\n5.在每个`` {% for %}``循环里有一个称为`` forloop`` 的模板变量。这个变量有一些提示循环进度信息的属性。\r\n\r\nforloop.counter 总是一个表示当前循环的执行次数的整数计数器。 这个计数器是从1开始的，所以在第一次循环时forloop.counter 将会被设置为1。\r\n\r\n{% for item in todo_list %}\r\n    <p>{{ forloop.counter }}: {{ item }}</p>\r\n{% endfor %}\r\nforloop.counter0 类似于forloop.counter ，但是它是从0计数的。 第一次执行循环时这个变量会被设置为0。\r\n\r\nforloop.revcounter 是表示循环中剩余项的整型变量。 在循环初次执行时forloop.revcounter 将被设置为序列中项的总数。 最后一次循环执行中，这个变量将被置1。\r\n\r\nforloop.revcounter0 类似于forloop.revcounter ，但它以0做为结束索引。在第一次执行循环时，该变量会被置为序列的项的个数减1。\r\n\r\nforloop.first 是一个布尔值，如果该迭代是第一次执行，那么它被置为```` 在下面的情形中这个变量是很有用的：\r\n\r\nSystem Message: WARNING/2 (<string>, line 1071);backlink\r\n\r\nInline literal start-string without end-string.\r\n\r\n{% for object in objects %}\r\n    {% if forloop.first %}<li class=\"first\">{% else %}<li>{% endif %}\r\n    {{ object }}\r\n    </li>\r\n{% endfor %}\r\nforloop.last 是一个布尔值；在最后一次执行循环时被置为True。 一个常见的用法是在一系列的链接之间放置管道符（|），另一个常见的用途是为列表的每个单词的加上逗号。\r\n\r\n{% for link in links %}{{ link }}{% if not forloop.last %} | {% endif %}{% endfor %}\r\n上面的模板可能会产生如下的结果：\r\n\r\nLink1 | Link2 | Link3 | Link4\r\n      forloop.parentloop 是一个指向当前循环的上一级循环的forloop 对象的引用（在嵌套循环的情况下）。\r\n{% for country in countries %}\r\n    <table>\r\n    {% for city in country.city_list %}\r\n        <tr>\r\n        <td>Country #{{ forloop.parentloop.counter }}</td>\r\n        <td>City #{{ forloop.counter }}</td>\r\n        <td>{{ city }}</td>\r\n        </tr>\r\n    {% endfor %}\r\n    </table>\r\n{% endfor %}\r\nforloop 变量仅仅能够在循环中使用。 在模板解析器碰到{%endfor%}标签后，forloop就不可访问了。\r\n\r\n6. Context和forloop变量\r\n\r\n在一个 {% for%} 块中，已存在的变量会被移除，以避免forloop 变量被覆盖。 Django会把这个变量移动到forloop.parentloop 中。通常我们不用担心这个问题，但是一旦我们在模板中定义了forloop 这个变量（当然我们反对这样做），在{%for%} 块中它会在forloop.parentloop 被重新命名。\r\nifequal/ifnotequal 标签\r\n1. {% ifequal %} 标签比较两个值，当他们相等时，显示在 {% ifequal %} 和 {% endifequal %} 之中所有的值。\r\n\r\n下面的例子比较两个模板变量 user 和 currentuser :\r\n\r\n{% ifequal user currentuser %}\r\n    <h1>Welcome!</h1>\r\n{% endifequal %}\r\nNote:只有模板变量，字符串，整数和小数可以作为 {% ifequal %} 标签的参数。其他任何类型，例如Python的字典类型、列表类型、布尔类型，不能用在{%ifequal%} 中。\r\n\r\n2. {% ifequal %} 支持可选的 {% else%} 标签：8\r\n\r\n{% ifequal section \'sitenews\' %}\r\n    <h1>Site News</h1>\r\n{% else %}\r\n    <h1>No News Here</h1>\r\n{% endifequal %}\r\n注释标签\r\n1. Django单行注释使用 {# #}。\r\n\r\n{# 这是一个注释 #}\r\n用这种语法的注释不能跨越多行。 这个限制是为了提高模板解析的性能。 在下面这个模板中，输出结果和模板本身是 完全一样的（也就是说，注释标签并没有被解析为注释）：\r\n\r\nThis is a {# this is not\r\na comment #}\r\ntest.\r\n2. 实现多行注释，可以使用`` {% comment %}`` 模板标签\r\n\r\n{% comment %}\r\nThis is a\r\nmulti-line comment.\r\n{% endcomment %}\r\n过滤器\r\n1. 模板过滤器可以在变量被显示前修改它，过滤器使用管道字符，如下所示：\r\n\r\n{{ name|lower }}\r\n{{ name }} 变量被过滤器 lower 处理后，文档大写转换文本为小写。\r\n\r\n2. 过滤管道可以被* 套接* ，既是说，一个过滤器管道的输出又可以作为下一个管道的输入：\r\n\r\n{{ my_list|first|upper }}\r\n以上实例将第一个元素并将其转化为大写。\r\n\r\nNote:另一种实现\r\n\r\n{{ django|title }}\r\n3. 有些过滤器有参数。 过滤器的参数跟随冒号之后并且总是以双引号包含。 例如：\r\n{{ bio|truncatewords:\"30\" }}\r\n这个将显示变量 bio 的前30个词。 \r\n\r\n4.linebreaks\r\n\r\nReplaces line breaks in plain text with appropriate HTML; a singlenewline becomes an HTML line break (<br/>) and a new linefollowed by a blank line becomes a paragraph break (</p>).\r\n\r\nFor example:\r\n\r\n{{ value|linebreaks }}\r\nIf value is Joel\\nis a slug, the output will be<p>Joel<br/>is aslug</p>.\r\n\r\nlinebreaksbr\r\n\r\nConverts all newlines in a piece of plain text to HTML line breaks(<br/>).\r\n\r\nFor example:\r\n\r\n{{ value|linebreaksbr }}\r\nIf value is Joel\\nis a slug, the output will beJoel<br/>isaslug.\r\n\r\n5. 其他过滤器：\r\naddslashes : 添加反斜杠到任何反斜杠、单引号或者双引号前面。\r\ndate : 按指定的格式字符串参数格式化 date 或者 datetime 对象，实例：\r\n{{ pub_date|date:\"F j, Y\" }}     #将变量ship_date传递给date过滤器，同时指定参数”F j,Y”。date过滤器根据参数进行格式输出。如时间的显示 April 2, 2009 是按 \'F j, Y\' 格式显示的。\r\nlength : 返回变量的长度。你可以对列表或者字符串，或者任何知道怎么测定长度的Python 对象使用这个方法（也就是说，有 __len__() 方法的对象）。\r\nNote:过滤器是用管道符(|)来调用的，具体可以参见Unix管道符。\r\n\r\n[Built-in filter reference]\r\n\r\n[Writing custom template filters]\r\n\r\ninclude 标签\r\n该标签允许在（模板中）包含其它的模板的内容。 标签的参数是所要包含的模板名称，可以是一个变量，也可以是用单/双引号硬编码的字符串。 每当在多个模板中出现相同的代码时，就应该考虑是否要使用{%include%} 来减少重复。\r\n下面这两个例子都包含了 nav.html 模板：\r\n\r\n{% include \"nav.html\" %}\r\nNote:\r\n\r\n1. 和在 get_template() 中一样， 对模板的文件名进行判断时会在所调取的模板名称之前加上来自TEMPLATE_DIRS 的模板目录。\r\n\r\n2.如果{%include%}标签指定的模板没找到，Django将会在下面两个处理方法中选择一个：\r\n\r\n如果 DEBUG 设置为 True ，你将会在 Django 错误信息页面看到TemplateDoesNotExist 异常。\r\n\r\n如果 DEBUG 设置为 False ，该标签不会引发错误信息，在标签位置不显示任何东西。\r\n\r\nURL标签\r\n\r\nurl的用法也很简单，只要在urlpatterns里使用它，附加一个name，如：\r\n\r\nurl(r\'^article$\',\'news_index\' ，name=\"news_index\"),\r\nTemplates里 这样使用\r\n{%url \'name\'%}\r\n地址链接就能使用了。\r\nNote:name是全局的，你整个urlpatterns里只能一个唯一的name，这个道理应该好理解，就像网站的地址也是唯一性的。\r\n\r\nviews里怎么用以及urlpatterns的地址包含有参数的时候<a href=\"{%url \'news_archive\' 2010  02%}\">2010年02月</a>时可参考[Django url 标签的使用]\r\n\r\n\r\n\r\n模板继承\r\n\r\n模板可以用继承的方式来实现复用。在整个网站中，如何减少共用页面区域（比如站点导航）所引起的重复和冗余代码？\r\n\r\n解决该问题的传统做法是使用 服务器端的 includes ，你可以在 HTML 页面中使用该指令将一个网页嵌入到另一个中。 事实上， Django 通过刚才讲述的 {% include %} 支持了这种方法。 但是用 Django 解决此类问题的首选方法是使用更加优雅的策略—— 模板继承 。本质上来说，模板继承就是先构造一个基础框架模板，而后在其子模板中对它所包含站点公用部分和定义块进行重载。你可以将其视为服务器端 include 的逆向思维版本。 你可以对那些 不同 的代码段进行定义，而不是 共同 代码段。\r\n\r\n第一步是定义 基础模板 ， 该框架之后将由 子模板 所继承。 基础模板：\r\n\r\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\">\r\n<html lang=\"en\">\r\n<head>\r\n    <title>{% block title %}{% endblock %}</title>\r\n</head>\r\n<body>\r\n    <h1>My helpful timestamp site</h1>\r\n    {% block content %}{% endblock %}\r\n    {% block footer %}\r\n    <hr>\r\n    <p>Thanks for visiting my site.</p>\r\n    {% endblock %}\r\n</body>\r\n</html>\r\nNote:\r\n1. 所有的 {% block %} 标签告诉模板引擎，子模板可以重载这些部分。每个{%block%}标签所要做的是告诉模板引擎，该模板下的这一块内容将有可能被子模板覆盖。\r\n\r\n2.注意由于子模板并没有定义 footer 块，模板系统将使用在父模板中定义的值。 父模板{%block%} 标签中的内容总是被当作一条退路。\r\n\r\n3. 继承并不会影响到模板的上下文。 换句话说，任何处在继承树上的模板都可以访问到你传到模板中的每一个模板变量。\r\n\r\n4. 你可以根据需要使用任意多的继承次数。\r\n\r\n使用继承的一种常见方式是下面的三层法：\r\n\r\n创建 base.html 模板，在其中定义站点的主要外观感受。 这些都是不常修改甚至从不修改的部分。\r\n\r\n为网站的每个区域创建 base_SECTION.html 模板(例如,base_photos.html 和base_forum.html )。这些模板对base.html 进行拓展，并包含区域特定的风格与设计。\r\n\r\n为每种类型的页面创建独立的模板，例如论坛页面或者图片库。 这些模板拓展相应的区域模板。\r\n\r\n使用模板继承的一些诀窍：\r\n\r\n如果在模板中使用 {%extends%} ，必须保证其为模板中的第一个模板标记。 否则，模板继承将不起作用。\r\n\r\n一般来说，基础模板中的 {%block%} 标签越多越好。记住，子模板不必定义父模板中所有的代码块，因此你可以用合理的缺省值对一些代码块进行填充，然后只对子模板所需的代码块进行（重）定义。 俗话说，钩子越多越好。\r\n\r\n如果发觉自己在多个模板之间拷贝代码，你应该考虑将该代码段放置到父模板的某个 {% block %} 中。\r\n\r\n如果你需要访问父模板中的块的内容，使用 {{block.super}}这个标签吧，这一个魔法变量将会表现出父模板中的内容。 如果只想在上级代码块基础上添加内容，而不是全部重载，该变量就显得非常有用了。\r\n\r\n不允许在同一个模板中定义多个同名的 {%block%} 。 存在这样的限制是因为block 标签的工作方式是双向的。 也就是说，block 标签不仅挖了一个要填的坑，也定义了在父模板中这个坑所填充的内容。如果模板中出现了两个相同名称的{% block %} 标签，父模板将无从得知要使用哪个块的内容。\r\n\r\n{%extends%} 对所传入模板名称使用的加载方法和get_template() 相同。 也就是说，会将模板名称被添加到TEMPLATE_DIRS 设置之后。\r\n\r\n多数情况下， {%extends%} 的参数应该是字符串，但是如果直到运行时方能确定父模板名，这个参数也可以是个变量。 这使得你能够实现一些很酷的动态功能。\r\n\r\nfrom:http://blog.csdn.net/pipisorry/article/details/45727309\r\n\r\nThe Django template language','2018-03-21 09:45:54.976939','2018-03-21 09:45:54.976970','p','',3,0,'',0,1,1,'r'),(16,'localStorage','Html5可以通过localStorage把服务器端的数据保存到本地，类型是Object，这样下次 加载的时候不用去服务器端取数据，可以直接从本地localStorage拿，增加网页Loading速度。 var object = [{\'a\':1,\'b\',2}]; var data = JSON.stringfy(object); localStorage.setItem(\'objectData\',data);\r\n\r\n如果需要取数据，那么是下面的方法： var getData = localStorage.getItem(\'objectData\'); console.log(JSON.parse(getData))','2018-03-21 10:26:17.290560','2018-03-21 10:26:17.290593','p','',0,0,'',0,1,6,'o');
/*!40000 ALTER TABLE `Article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `Article_tags`
--

DROP TABLE IF EXISTS `Article_tags`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `Article_tags` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `article_id` int(11) NOT NULL,
  `tag_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `article_id` (`article_id`,`tag_id`),
  KEY `Article_tags_tag_id_5d73b5128ea253bd_fk_Tag_id` (`tag_id`),
  CONSTRAINT `Article_tags_article_id_1421cb269593a3b3_fk_Article_id` FOREIGN KEY (`article_id`) REFERENCES `Article` (`id`),
  CONSTRAINT `Article_tags_tag_id_5d73b5128ea253bd_fk_Tag_id` FOREIGN KEY (`tag_id`) REFERENCES `Tag` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Article_tags`
--

LOCK TABLES `Article_tags` WRITE;
/*!40000 ALTER TABLE `Article_tags` DISABLE KEYS */;
INSERT INTO `Article_tags` VALUES (11,1,7),(10,2,3),(3,3,2),(6,3,3),(7,3,4),(8,3,5),(9,4,6),(16,5,1),(15,9,1),(17,10,1),(18,11,1),(19,12,1),(22,13,7),(20,13,8),(21,14,9),(23,15,1),(24,16,2);
/*!40000 ALTER TABLE `Article_tags` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `Category`
--

DROP TABLE IF EXISTS `Category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `Category` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(20) NOT NULL,
  `created_time` datetime(6) NOT NULL,
  `last_modified_time` datetime(6) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Category`
--

LOCK TABLES `Category` WRITE;
/*!40000 ALTER TABLE `Category` DISABLE KEYS */;
INSERT INTO `Category` VALUES (1,'Django','2018-01-27 00:00:00.000000','2018-01-27 09:33:24.493196'),(5,'Python','2018-03-08 10:07:33.864001','2018-03-08 10:07:33.864028'),(6,'前端','2018-03-08 10:07:42.338543','2018-03-21 09:15:03.930623'),(7,'情感','2018-03-08 10:09:57.824166','2018-03-20 17:32:49.323171'),(8,'区块链','2018-03-20 17:45:07.954897','2018-03-20 17:45:07.954927');
/*!40000 ALTER TABLE `Category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `Comment`
--

DROP TABLE IF EXISTS `Comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `Comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) NOT NULL,
  `email` varchar(255) NOT NULL,
  `url` varchar(200) NOT NULL,
  `text` longtext NOT NULL,
  `created_time` datetime(6) NOT NULL,
  `post_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `comments_comment_post_id_4f96c2b22d998900_fk_Article_id` (`post_id`),
  CONSTRAINT `comments_comment_post_id_4f96c2b22d998900_fk_Article_id` FOREIGN KEY (`post_id`) REFERENCES `Article` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Comment`
--

LOCK TABLES `Comment` WRITE;
/*!40000 ALTER TABLE `Comment` DISABLE KEYS */;
INSERT INTO `Comment` VALUES (1,'孙强','530631372@qq.com','','不错','2018-01-28 21:33:48.779369',5),(2,'孙强','','','测试评论功能','2018-03-07 22:18:41.996048',4),(3,'tim','','','美女真漂亮O(∩_∩)O哈哈~☺','2018-03-08 16:42:40.492897',1),(4,'孙强','','','This is A test','2018-03-11 15:41:36.867999',1),(5,'八级大狂风','','','这是在怎么回事？','2018-03-15 13:08:39.680101',10),(6,'骑摩托看世界','','','区块链必成为未来互联网的基础，去中心化也会未来互联网的趋势','2018-03-20 17:50:51.301309',14),(7,'泰伦卢','','','区块链技术不仅产生了比特币，未来会有越来越多的互联网产物使用区块链技术！','2018-03-20 17:53:15.165857',14);
/*!40000 ALTER TABLE `Comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `Tag`
--

DROP TABLE IF EXISTS `Tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `Tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Tag`
--

LOCK TABLES `Tag` WRITE;
/*!40000 ALTER TABLE `Tag` DISABLE KEYS */;
INSERT INTO `Tag` VALUES (1,'django'),(2,'js'),(3,'html'),(4,'jquery'),(5,'Ajax'),(6,'情感'),(7,'python'),(8,'爬虫'),(9,'区块链'),(10,'test');
/*!40000 ALTER TABLE `Tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `User`
--

DROP TABLE IF EXISTS `User`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `User` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(20) NOT NULL,
  `password` varchar(100) NOT NULL,
  `email` varchar(254) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `User`
--

LOCK TABLES `User` WRITE;
/*!40000 ALTER TABLE `User` DISABLE KEYS */;
/*!40000 ALTER TABLE `User` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_group`
--

DROP TABLE IF EXISTS `auth_group`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_group` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(80) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_group`
--

LOCK TABLES `auth_group` WRITE;
/*!40000 ALTER TABLE `auth_group` DISABLE KEYS */;
INSERT INTO `auth_group` VALUES (2,'320');
/*!40000 ALTER TABLE `auth_group` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_group_permissions`
--

DROP TABLE IF EXISTS `auth_group_permissions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_group_permissions` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `group_id` int(11) NOT NULL,
  `permission_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `group_id` (`group_id`,`permission_id`),
  KEY `auth_group__permission_id_1f49ccbbdc69d2fc_fk_auth_permission_id` (`permission_id`),
  CONSTRAINT `auth_group__permission_id_1f49ccbbdc69d2fc_fk_auth_permission_id` FOREIGN KEY (`permission_id`) REFERENCES `auth_permission` (`id`),
  CONSTRAINT `auth_group_permission_group_id_689710a9a73b7457_fk_auth_group_id` FOREIGN KEY (`group_id`) REFERENCES `auth_group` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=30 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_group_permissions`
--

LOCK TABLES `auth_group_permissions` WRITE;
/*!40000 ALTER TABLE `auth_group_permissions` DISABLE KEYS */;
INSERT INTO `auth_group_permissions` VALUES (19,2,13),(20,2,14),(21,2,19),(22,2,20),(23,2,22),(24,2,23),(25,2,25),(28,2,26),(26,2,28),(27,2,29),(29,2,30);
/*!40000 ALTER TABLE `auth_group_permissions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_permission`
--

DROP TABLE IF EXISTS `auth_permission`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_permission` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `content_type_id` int(11) NOT NULL,
  `codename` varchar(100) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `content_type_id` (`content_type_id`,`codename`),
  CONSTRAINT `auth__content_type_id_508cf46651277a81_fk_django_content_type_id` FOREIGN KEY (`content_type_id`) REFERENCES `django_content_type` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=34 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_permission`
--

LOCK TABLES `auth_permission` WRITE;
/*!40000 ALTER TABLE `auth_permission` DISABLE KEYS */;
INSERT INTO `auth_permission` VALUES (1,'Can add log entry',1,'add_logentry'),(2,'Can change log entry',1,'change_logentry'),(3,'Can delete log entry',1,'delete_logentry'),(4,'Can add permission',2,'add_permission'),(5,'Can change permission',2,'change_permission'),(6,'Can delete permission',2,'delete_permission'),(7,'Can add group',3,'add_group'),(8,'Can change group',3,'change_group'),(9,'Can delete group',3,'delete_group'),(10,'Can add user',4,'add_user'),(11,'Can change user',4,'change_user'),(12,'Can delete user',4,'delete_user'),(13,'Can add content type',5,'add_contenttype'),(14,'Can change content type',5,'change_contenttype'),(15,'Can delete content type',5,'delete_contenttype'),(16,'Can add session',6,'add_session'),(17,'Can change session',6,'change_session'),(18,'Can delete session',6,'delete_session'),(19,'Can add tag',7,'add_tag'),(20,'Can change tag',7,'change_tag'),(21,'Can delete tag',7,'delete_tag'),(22,'Can add category',8,'add_category'),(23,'Can change category',8,'change_category'),(24,'Can delete category',8,'delete_category'),(25,'Can add article',9,'add_article'),(26,'Can change article',9,'change_article'),(27,'Can delete article',9,'delete_article'),(28,'Can add comment',10,'add_comment'),(29,'Can change comment',10,'change_comment'),(30,'Can delete comment',10,'delete_comment'),(31,'Can add user',11,'add_user'),(32,'Can change user',11,'change_user'),(33,'Can delete user',11,'delete_user');
/*!40000 ALTER TABLE `auth_permission` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_user`
--

DROP TABLE IF EXISTS `auth_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `password` varchar(128) NOT NULL,
  `last_login` datetime(6) DEFAULT NULL,
  `is_superuser` tinyint(1) NOT NULL,
  `username` varchar(30) NOT NULL,
  `first_name` varchar(30) NOT NULL,
  `last_name` varchar(30) NOT NULL,
  `email` varchar(254) NOT NULL,
  `is_staff` tinyint(1) NOT NULL,
  `is_active` tinyint(1) NOT NULL,
  `date_joined` datetime(6) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `username` (`username`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_user`
--

LOCK TABLES `auth_user` WRITE;
/*!40000 ALTER TABLE `auth_user` DISABLE KEYS */;
INSERT INTO `auth_user` VALUES (1,'pbkdf2_sha256$24000$NSYoOYcO2XGx$HQHYGc6oN0rX+ua17Rw2vRnromhQcfYxTtg6dRAqGx0=','2018-03-07 21:59:14.260759',1,'tim','','','530631372@qq.com',1,1,'2018-01-27 09:32:01.270264'),(2,'pbkdf2_sha256$24000$05UGrjZ1F6mc$vVxfD0toNhtybOx1PT9J2WywVf/ZXcwh6+41yru6lL4=','2018-03-20 21:21:47.007488',1,'sunqiang','','','530631372@qq.com',1,1,'2018-03-07 21:56:35.000000'),(5,'pbkdf2_sha256$24000$pPlQEQIWXJZX$0R8HEhqCaOvpbkqNqH45BxpOg91mSCDJRNWPUOhNdF4=','2018-03-13 16:54:17.492789',0,'admin_320','','','',1,1,'2018-03-12 17:36:47.000000');
/*!40000 ALTER TABLE `auth_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_user_groups`
--

DROP TABLE IF EXISTS `auth_user_groups`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_user_groups` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `group_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `user_id` (`user_id`,`group_id`),
  KEY `auth_user_groups_group_id_33ac548dcf5f8e37_fk_auth_group_id` (`group_id`),
  CONSTRAINT `auth_user_groups_group_id_33ac548dcf5f8e37_fk_auth_group_id` FOREIGN KEY (`group_id`) REFERENCES `auth_group` (`id`),
  CONSTRAINT `auth_user_groups_user_id_4b5ed4ffdb8fd9b0_fk_auth_user_id` FOREIGN KEY (`user_id`) REFERENCES `auth_user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_user_groups`
--

LOCK TABLES `auth_user_groups` WRITE;
/*!40000 ALTER TABLE `auth_user_groups` DISABLE KEYS */;
INSERT INTO `auth_user_groups` VALUES (4,5,2);
/*!40000 ALTER TABLE `auth_user_groups` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_user_user_permissions`
--

DROP TABLE IF EXISTS `auth_user_user_permissions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_user_user_permissions` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `permission_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `user_id` (`user_id`,`permission_id`),
  KEY `auth_user_u_permission_id_384b62483d7071f0_fk_auth_permission_id` (`permission_id`),
  CONSTRAINT `auth_user_u_permission_id_384b62483d7071f0_fk_auth_permission_id` FOREIGN KEY (`permission_id`) REFERENCES `auth_permission` (`id`),
  CONSTRAINT `auth_user_user_permissi_user_id_7f0938558328534a_fk_auth_user_id` FOREIGN KEY (`user_id`) REFERENCES `auth_user` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_user_user_permissions`
--

LOCK TABLES `auth_user_user_permissions` WRITE;
/*!40000 ALTER TABLE `auth_user_user_permissions` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_user_user_permissions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_admin_log`
--

DROP TABLE IF EXISTS `django_admin_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_admin_log` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `action_time` datetime(6) NOT NULL,
  `object_id` longtext,
  `object_repr` varchar(200) NOT NULL,
  `action_flag` smallint(5) unsigned NOT NULL,
  `change_message` longtext NOT NULL,
  `content_type_id` int(11) DEFAULT NULL,
  `user_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `djang_content_type_id_697914295151027a_fk_django_content_type_id` (`content_type_id`),
  KEY `django_admin_log_user_id_52fdd58701c5f563_fk_auth_user_id` (`user_id`),
  CONSTRAINT `djang_content_type_id_697914295151027a_fk_django_content_type_id` FOREIGN KEY (`content_type_id`) REFERENCES `django_content_type` (`id`),
  CONSTRAINT `django_admin_log_user_id_52fdd58701c5f563_fk_auth_user_id` FOREIGN KEY (`user_id`) REFERENCES `auth_user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=129 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_admin_log`
--

LOCK TABLES `django_admin_log` WRITE;
/*!40000 ALTER TABLE `django_admin_log` DISABLE KEYS */;
INSERT INTO `django_admin_log` VALUES (1,'2018-01-27 09:33:24.493752','1','Django',1,'',8,1),(2,'2018-01-27 09:33:33.948538','1','django',1,'',7,1),(3,'2018-01-27 09:33:39.824339','1','This is a test',1,'',9,1),(4,'2018-01-27 09:40:44.491645','2','js',1,'',7,1),(5,'2018-01-27 09:40:48.911374','2','wrarfqe',1,'',9,1),(6,'2018-01-27 09:41:32.282104','3','qwdqw',1,'',9,1),(7,'2018-01-27 09:41:56.596578','4','dgsdgv',1,'',9,1),(8,'2018-01-27 14:12:18.708373','2','test',1,'Added.',8,1),(9,'2018-01-27 14:12:34.398846','3','test',1,'Added.',8,1),(10,'2018-01-27 14:12:42.441230','4','test',1,'Added.',8,1),(11,'2018-01-27 14:12:56.431363','4','dgsdgv',2,'Changed body.',9,1),(12,'2018-01-27 14:13:43.668681','3','qwdqw',2,'Changed body.',9,1),(13,'2018-01-27 14:14:23.300132','2','wrarfqe',2,'Changed body.',9,1),(14,'2018-01-28 21:25:09.578010','5','Django QuerySet API文档',1,'Added.',9,1),(15,'2018-03-07 22:06:19.955390','4','dgsdgv',2,'Changed body.',9,1),(16,'2018-03-07 22:36:57.856282','4','dgsdgv',2,'Changed imgurl.',9,2),(17,'2018-03-07 22:37:27.399765','3','qwdqw',2,'Changed imgurl.',9,2),(18,'2018-03-08 10:06:34.996772','3','html',1,'Added.',7,2),(19,'2018-03-08 10:06:52.510970','4','jquery',1,'Added.',7,2),(20,'2018-03-08 10:06:57.490106','5','Ajax',1,'Added.',7,2),(21,'2018-03-08 10:07:15.940951','2','test',3,'',8,2),(22,'2018-03-08 10:07:22.321440','3','test',3,'',8,2),(23,'2018-03-08 10:07:27.270988','4','test',3,'',8,2),(24,'2018-03-08 10:07:33.866469','5','Python',1,'Added.',8,2),(25,'2018-03-08 10:07:42.338974','6','Html',1,'Added.',8,2),(26,'2018-03-08 10:07:55.769110','3','Django+Markdown+Pygments 支持Markdown 实现代码高亮',2,'Changed title, body, views, likes, imgurl, tags and author.',9,2),(27,'2018-03-08 10:09:57.826684','7','Emotion',1,'Added.',8,2),(28,'2018-03-08 10:10:05.760130','6','emotion',1,'Added.',7,2),(29,'2018-03-08 10:10:10.763740','4','程序员如何修复婚姻的bug',2,'Changed title, body, category and tags.',9,2),(30,'2018-03-08 10:11:22.439862','3','Django+Markdown+Pygments 支持Markdown 实现代码高亮',2,'Changed imgurl.',9,2),(31,'2018-03-08 10:17:23.528250','3','Django+Markdown+Pygments 支持Markdown 实现代码高亮',2,'Changed body.',9,2),(32,'2018-03-08 10:18:24.678687','3','Django+Markdown+Pygments 支持Markdown 实现代码高亮',2,'Changed body.',9,2),(33,'2018-03-08 10:19:47.617989','3','Django+Markdown+Pygments 支持Markdown 实现代码高亮',2,'Changed body.',9,2),(34,'2018-03-08 10:20:26.341379','3','Django+Markdown+Pygments 支持Markdown 实现代码高亮',2,'Changed body.',9,2),(35,'2018-03-08 10:20:42.652009','3','Django+Markdown+Pygments 支持Markdown 实现代码高亮',2,'Changed body.',9,2),(36,'2018-03-08 10:21:00.060704','3','Django+Markdown+Pygments 支持Markdown 实现代码高亮',2,'Changed body.',9,2),(37,'2018-03-08 10:21:03.720492','3','Django+Markdown+Pygments 支持Markdown 实现代码高亮',2,'No fields changed.',9,2),(38,'2018-03-08 10:22:36.604618','3','Django+Markdown+Pygments 支持Markdown 实现代码高亮',2,'No fields changed.',9,2),(39,'2018-03-08 10:23:26.957044','3','Django+Markdown+Pygments 支持Markdown 实现代码高亮',2,'Changed body.',9,2),(40,'2018-03-08 10:26:01.237558','2','根据html页面id寻找对应的Js文件',2,'Changed title, body, imgurl, category and tags.',9,2),(41,'2018-03-08 10:27:57.299122','7','python',1,'Added.',7,2),(42,'2018-03-08 10:28:01.314184','1','ython datetime timestamp',2,'Changed title, body, imgurl, category and tags.',9,2),(43,'2018-03-08 10:28:33.512981','1','Python datetime timestamp',2,'Changed title.',9,2),(44,'2018-03-11 15:40:58.382613','2','sunqiang',2,'No fields changed.',4,2),(45,'2018-03-12 14:20:04.635735','1','320',1,'Added.',3,2),(46,'2018-03-12 14:20:58.695928','2','sunqiang',2,'No fields changed.',4,2),(47,'2018-03-12 14:21:31.900619','2','sunqiang',2,'Changed groups.',4,2),(48,'2018-03-12 14:23:38.940319','6','python爬取youtube视频 多线程',1,'Added.',9,2),(49,'2018-03-12 14:24:26.408469','6','python爬取youtube视频 多线程',3,'',9,2),(50,'2018-03-12 14:25:43.815392','3','timsun',1,'Added.',4,2),(51,'2018-03-12 14:26:17.841113','3','timsun',2,'Changed groups.',4,2),(52,'2018-03-12 14:28:27.795947','3','timsun',3,'',4,2),(53,'2018-03-12 14:31:39.756856','4','admin_320',1,'Added.',4,2),(54,'2018-03-12 14:32:11.100119','4','admin_320',2,'Changed is_staff and groups.',4,2),(56,'2018-03-12 15:03:57.364358','7','采集知乎用户数据',3,'',9,2),(57,'2018-03-12 15:04:49.573344','8','tessss',1,'Added.',9,2),(58,'2018-03-12 15:05:17.427974','8','tessss',2,'Changed author.',9,2),(59,'2018-03-12 15:06:28.135883','8','tessss',2,'Changed imgurl.',9,2),(60,'2018-03-12 15:07:52.388553','1','320',3,'',3,2),(61,'2018-03-12 15:08:16.623365','4','admin_320',3,'',4,2),(62,'2018-03-12 15:08:36.338973','8','tessss',2,'Changed author.',9,2),(63,'2018-03-12 17:20:19.883379','8','tessss',3,'',9,1),(64,'2018-03-12 17:32:58.869464','9','Django Pagination',1,'Added.',9,1),(65,'2018-03-12 17:33:55.878767','9','Django Pagination',2,'Changed body.',9,1),(66,'2018-03-12 17:36:14.915981','2','320',1,'Added.',3,1),(67,'2018-03-12 17:36:47.119972','5','admin_320',1,'Added.',4,1),(68,'2018-03-12 17:37:00.567066','5','admin_320',2,'Changed is_staff and groups.',4,1),(69,'2018-03-12 17:38:42.428383','2','320',2,'Changed permissions.',3,2),(70,'2018-03-12 17:42:18.243091','1','Python datetime timestamp',2,'Changed body.',9,5),(71,'2018-03-12 17:43:17.136013','1','Python datetime timestamp',2,'Changed body.',9,5),(72,'2018-03-12 17:43:51.151650','1','Python datetime timestamp',2,'Changed body.',9,5),(73,'2018-03-12 17:44:24.135096','1','Python datetime timestamp',2,'Changed body.',9,5),(74,'2018-03-12 17:45:19.117407','1','Python datetime timestamp',2,'Changed body.',9,5),(75,'2018-03-13 10:52:07.821395','5','Django QuerySet API文档',2,'Changed category and tags.',9,5),(76,'2018-03-13 14:24:57.778978','10','DJANGO ADMIN 一些有用的设置',1,'Added.',9,5),(77,'2018-03-13 14:26:14.415706','11','DJANGO XADMIN的使用 （一）',1,'Added.',9,5),(78,'2018-03-13 14:28:04.897289','12','DJANGO XADMIN的使用 （二）',1,'Added.',9,5),(79,'2018-03-13 15:45:12.699078','2','320',2,'已修改 permissions 。',3,2),(80,'2018-03-15 13:05:18.053954','10','DJANGO ADMIN 一些有用的设置',2,'已修改 body 。',9,5),(81,'2018-03-15 13:06:18.909908','5','Django QuerySet API文档',2,'已修改 body 。',9,5),(82,'2018-03-15 13:07:30.119962','10','DJANGO ADMIN 一些有用的设置',2,'已修改 body 。',9,5),(83,'2018-03-20 11:52:25.974905','2','根据html页面id寻找对应的Js文件',2,'已修改 property 。',9,5),(84,'2018-03-20 14:07:06.269913','8','爬虫',1,'已添加。',7,2),(85,'2018-03-20 14:07:15.731123','13','Python爬取内涵段子搞笑视频',1,'已添加。',9,2),(86,'2018-03-20 15:16:04.257239','13','Python爬取内涵段子搞笑视频',2,'已修改 body 。',9,2),(87,'2018-03-20 15:17:04.359967','13','Python爬取内涵段子搞笑视频',2,'已修改 body 。',9,2),(88,'2018-03-20 15:18:55.970618','13','Python爬取内涵段子搞笑视频',2,'已修改 body 。',9,2),(89,'2018-03-20 15:20:49.729514','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(90,'2018-03-20 15:22:28.204283','13','Python爬取内涵段子搞笑视频',2,'已修改 body 。',9,2),(91,'2018-03-20 15:23:20.069202','13','Python爬取内涵段子搞笑视频',2,'已修改 body 。',9,2),(92,'2018-03-20 15:23:46.573092','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(93,'2018-03-20 15:25:20.160863','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(94,'2018-03-20 15:26:27.325510','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(95,'2018-03-20 15:28:09.480208','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(96,'2018-03-20 15:28:42.625036','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(97,'2018-03-20 15:29:25.084119','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(98,'2018-03-20 15:29:50.764187','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(99,'2018-03-20 15:30:24.392884','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(100,'2018-03-20 15:30:45.025370','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(101,'2018-03-20 15:31:19.206623','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(102,'2018-03-20 15:31:37.708782','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(103,'2018-03-20 15:33:40.581619','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(104,'2018-03-20 15:35:07.636108','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(105,'2018-03-20 15:35:28.276571','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(106,'2018-03-20 15:36:19.075323','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(107,'2018-03-20 15:37:33.387692','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(108,'2018-03-20 15:55:21.270756','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(109,'2018-03-20 15:57:07.590010','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(110,'2018-03-20 15:58:39.906599','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 views 。',9,2),(111,'2018-03-20 17:31:39.983669','6','情感',2,'已修改 name 。',7,2),(112,'2018-03-20 17:32:27.376582','6','情感',2,'没有字段被修改。',7,2),(113,'2018-03-20 17:32:49.339864','7','情感',2,'已修改 name 。',8,2),(114,'2018-03-20 17:45:07.956049','8','区块链',1,'已添加。',8,2),(115,'2018-03-20 17:45:14.973134','9','区块链',1,'已添加。',7,2),(116,'2018-03-20 17:45:26.507965','14','区块链',1,'已添加。',9,2),(117,'2018-03-20 17:46:05.985458','14','区块链',2,'已修改 body 。',9,2),(118,'2018-03-20 17:47:10.843637','14','区块链基本知识',2,'已修改 title 和 body 。',9,2),(119,'2018-03-20 17:49:36.869985','14','区块链基本知识',2,'已修改 body 。',9,2),(120,'2018-03-20 17:54:24.011107','8','区块链技术不仅产生了比特币，未来会有越来',3,'',10,2),(121,'2018-03-20 18:16:05.026872','13','Python爬取内涵段子搞笑视频',2,'已修改 topped 。',9,2),(122,'2018-03-20 21:23:04.151948','13','Python爬取内涵段子搞笑视频',2,'已修改 body 和 tags 。',9,2),(123,'2018-03-21 09:15:03.931519','6','前端',2,'已修改 name 。',8,2),(124,'2018-03-21 09:19:55.365162','10','test',1,'已添加。',7,2),(125,'2018-03-21 09:45:54.995893','15','Django模板语言',1,'已添加。',9,2),(126,'2018-03-21 09:46:14.612454','13','Python爬取内涵段子搞笑视频',2,'已修改 views 。',9,2),(127,'2018-03-21 10:26:17.336493','16','localStorage',1,'已添加。',9,2),(128,'2018-03-21 10:26:25.890020','13','Python爬取内涵段子搞笑视频',2,'已修改 views 。',9,2);
/*!40000 ALTER TABLE `django_admin_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_content_type`
--

DROP TABLE IF EXISTS `django_content_type`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_content_type` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `app_label` varchar(100) NOT NULL,
  `model` varchar(100) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `django_content_type_app_label_45f3b1d93ec8c61c_uniq` (`app_label`,`model`)
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_content_type`
--

LOCK TABLES `django_content_type` WRITE;
/*!40000 ALTER TABLE `django_content_type` DISABLE KEYS */;
INSERT INTO `django_content_type` VALUES (11,'account','user'),(1,'admin','logentry'),(3,'auth','group'),(2,'auth','permission'),(4,'auth','user'),(9,'Blog_Module','article'),(8,'Blog_Module','category'),(7,'Blog_Module','tag'),(10,'comments','comment'),(5,'contenttypes','contenttype'),(6,'sessions','session');
/*!40000 ALTER TABLE `django_content_type` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_migrations`
--

DROP TABLE IF EXISTS `django_migrations`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_migrations` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `app` varchar(255) NOT NULL,
  `name` varchar(255) NOT NULL,
  `applied` datetime(6) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_migrations`
--

LOCK TABLES `django_migrations` WRITE;
/*!40000 ALTER TABLE `django_migrations` DISABLE KEYS */;
INSERT INTO `django_migrations` VALUES (1,'contenttypes','0001_initial','2018-01-27 09:30:32.284998'),(2,'auth','0001_initial','2018-01-27 09:30:32.636131'),(3,'Blog_Module','0001_initial','2018-01-27 09:30:32.915767'),(4,'account','0001_initial','2018-01-27 09:30:32.936543'),(5,'admin','0001_initial','2018-01-27 09:30:34.215244'),(6,'contenttypes','0002_remove_content_type_name','2018-01-27 09:30:34.312385'),(7,'auth','0002_alter_permission_name_max_length','2018-01-27 09:30:34.361361'),(8,'auth','0003_alter_user_email_max_length','2018-01-27 09:30:34.407601'),(9,'auth','0004_alter_user_username_opts','2018-01-27 09:30:34.430905'),(10,'auth','0005_alter_user_last_login_null','2018-01-27 09:30:34.473478'),(11,'auth','0006_require_contenttypes_0002','2018-01-27 09:30:34.478343'),(12,'comments','0001_initial','2018-01-27 09:30:34.564441'),(13,'comments','0002_auto_20180122_0936','2018-01-27 09:30:34.587726'),(14,'sessions','0001_initial','2018-01-27 09:30:34.616458'),(15,'admin','0002_logentry_remove_auto_add','2018-01-27 10:02:53.821337'),(16,'auth','0007_alter_validators_add_error_messages','2018-01-27 10:02:53.929483'),(17,'Blog_Module','0002_auto_20180127_1017','2018-01-27 10:17:57.972794'),(18,'Blog_Module','0003_auto_20180127_1020','2018-01-27 10:20:06.467873'),(19,'comments','0003_auto_20180129_0914','2018-03-07 21:18:19.011873'),(20,'comments','0004_auto_20180224_0925','2018-03-07 21:18:19.053112'),(21,'Blog_Module','0002_article_property','2018-03-20 10:55:22.108866');
/*!40000 ALTER TABLE `django_migrations` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_session`
--

DROP TABLE IF EXISTS `django_session`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_session` (
  `session_key` varchar(40) NOT NULL,
  `session_data` longtext NOT NULL,
  `expire_date` datetime(6) NOT NULL,
  PRIMARY KEY (`session_key`),
  KEY `django_session_de54fa62` (`expire_date`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_session`
--

LOCK TABLES `django_session` WRITE;
/*!40000 ALTER TABLE `django_session` DISABLE KEYS */;
INSERT INTO `django_session` VALUES ('5wtsee2knkt2avwstwejd2yor9tcca6m','ZDI0NmI5YmQ1MjU5NmViOGFhNWI4YTIzM2Y2Nzg3NjEwNDE2MDExYjp7Il9hdXRoX3VzZXJfaGFzaCI6IjUxZTgwMDM3MTI5MTQ5ZTIzMDhjYjVkM2ViMTFkZWIzM2E2MDcwZTIiLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJkamFuZ28uY29udHJpYi5hdXRoLmJhY2tlbmRzLk1vZGVsQmFja2VuZCIsIl9hdXRoX3VzZXJfaWQiOiIyIn0=','2018-03-26 14:42:38.506940'),('6wmljr570hc59uhipyhwz4fkdzyt5jyd','ZDI0NmI5YmQ1MjU5NmViOGFhNWI4YTIzM2Y2Nzg3NjEwNDE2MDExYjp7Il9hdXRoX3VzZXJfaGFzaCI6IjUxZTgwMDM3MTI5MTQ5ZTIzMDhjYjVkM2ViMTFkZWIzM2E2MDcwZTIiLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJkamFuZ28uY29udHJpYi5hdXRoLmJhY2tlbmRzLk1vZGVsQmFja2VuZCIsIl9hdXRoX3VzZXJfaWQiOiIyIn0=','2018-03-21 22:36:37.442810'),('ed2jrk7lbmk7jrkoarhsv165c3rvl01k','ZDI0NmI5YmQ1MjU5NmViOGFhNWI4YTIzM2Y2Nzg3NjEwNDE2MDExYjp7Il9hdXRoX3VzZXJfaGFzaCI6IjUxZTgwMDM3MTI5MTQ5ZTIzMDhjYjVkM2ViMTFkZWIzM2E2MDcwZTIiLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJkamFuZ28uY29udHJpYi5hdXRoLmJhY2tlbmRzLk1vZGVsQmFja2VuZCIsIl9hdXRoX3VzZXJfaWQiOiIyIn0=','2018-04-03 21:21:47.028417'),('qzii9tf5n8q64ndcbc6y84xvt86lm8xr','ZDI0NmI5YmQ1MjU5NmViOGFhNWI4YTIzM2Y2Nzg3NjEwNDE2MDExYjp7Il9hdXRoX3VzZXJfaGFzaCI6IjUxZTgwMDM3MTI5MTQ5ZTIzMDhjYjVkM2ViMTFkZWIzM2E2MDcwZTIiLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJkamFuZ28uY29udHJpYi5hdXRoLmJhY2tlbmRzLk1vZGVsQmFja2VuZCIsIl9hdXRoX3VzZXJfaWQiOiIyIn0=','2018-03-25 15:37:45.372821'),('v2olayzatsxj213h5s33j86dkhosse14','MzFiNmNiZmM0ODhlYTM5MGE4MmExZjRlMTAyODg5NGZiNTY5MTVjYjp7Il9hdXRoX3VzZXJfaGFzaCI6IjJmMzUyOTIyNjc4OGMzMzU3NjQyNDEwYWY0MTU1MjBhNDUwNDRjNTAiLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJkamFuZ28uY29udHJpYi5hdXRoLmJhY2tlbmRzLk1vZGVsQmFja2VuZCIsIl9hdXRoX3VzZXJfaWQiOiIxIn0=','2018-02-10 09:32:09.084856'),('z3sc4twjlwz8kwcmqv9p84sey72z51r4','ZDI0NmI5YmQ1MjU5NmViOGFhNWI4YTIzM2Y2Nzg3NjEwNDE2MDExYjp7Il9hdXRoX3VzZXJfaGFzaCI6IjUxZTgwMDM3MTI5MTQ5ZTIzMDhjYjVkM2ViMTFkZWIzM2E2MDcwZTIiLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJkamFuZ28uY29udHJpYi5hdXRoLmJhY2tlbmRzLk1vZGVsQmFja2VuZCIsIl9hdXRoX3VzZXJfaWQiOiIyIn0=','2018-04-03 12:36:04.396023');
/*!40000 ALTER TABLE `django_session` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2018-03-21 10:35:39
